{"docs":[{"location":"/logstage/sample.html","text":"","title":"Examples"},{"location":"/logstage/sample.html#examples","text":"","title":"Examples"},{"location":"/logstage/sample.html#logstage-config","text":"","title":"Logstage config"},{"location":"/logstage/sample.html#rendering-policy","text":"Input rendering policy (defined in config) is:\npolicy=\"${level}:${ts} ${thread}${location} ${custom-ctx} ${msg}\"\nLet’s send some logs\nval loggerWithContext = logger(\"userId\" -> \"xxx\")\nval loggerWithSubcontext = loggerWithContext(\"custom\" -> \"value\")\n\nval arg = \"this is an argument\"\n\nloggerWithContext.trace(s\"This would be automatically extended\")\nlogger.debug(s\"Service started. argument: $arg, Random value: ${Random.self.nextInt()}\")\nloggerWithSubcontext.info(\"Just a string\")\nlogger.warn(\"Just an integer: \" + 1)\nval arg1 = 5\nlogger.crit(s\"This is an expression: ${2 + 2 == 4} and this is an other one: ${5 * arg1 == 25}\")\nval t = new RuntimeException(\"Oy vey!\")\nlogger.crit(s\"A failure happened: $t\")\nThe final output will be:\nT:2018-05-07T14:31:43.045+03:00 ...leSinkTest:1 (LoggingMacroTest.scala:21) {userId=xxx} This would be automatically extended D:2018-05-07T14:31:43.083+03:00 ...leSinkTest:1 (LoggingMacroTest.scala:22) Service started. argument: arg=this is an argument, Random value: EXPRESSION:scala.util.Random.self.nextInt()=-1725949704 I:2018-05-07T14:31:43.086+03:00 ...leSinkTest:1 (LoggingMacroTest.scala:23) {userId=xxx, custom=value} Just a string; @type=const W:2018-05-07T14:31:43.090+03:00 ...leSinkTest:1 (LoggingMacroTest.scala:24) Just an integer: 1; @type=expr; @expr=\"Just an integer: \".+(1) C:2018-05-07T14:31:43.093+03:00 ...leSinkTest:1 (LoggingMacroTest.scala:26) This is an expression: UNNAMED:true=true and this is an other one: EXPRESSION:5.*(arg1).==(25)=true C:2018-05-07T14:31:43.095+03:00 ...leSinkTest:1 (LoggingMacroTest.scala:28) A failure happened: t=java.lang.RuntimeException: Oy vey! java.lang.RuntimeException: Oy vey! at com.github.pshirshov.izumi.logstage.api.routing.ExampleService.start(LoggingMacroTest.scala:27) at com.github.pshirshov.izumi.logstage.sink.console.LoggingConsoleSinkTest.$anonfun$new$3(LoggingConsoleSinkTest.scala:23) at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)","title":"Rendering policy"},{"location":"/logstage/sample.html#contexts-defintion","text":"","title":"Contexts defintion"},{"location":"/logstage/sample.html#sinks-configuration","text":"","title":"Sinks configuration"},{"location":"/logstage/sinks.html","text":"","title":""},{"location":"/logstage/contexts.html","text":"","title":""},{"location":"/index.html","text":"","title":"Izumi Toolkit"},{"location":"/index.html#izumi-toolkit","text":"TODO Sorry, this page is not ready yet","title":"Izumi Toolkit"},{"location":"/index.html#dependencies","text":"To use Izumi SBT Toolkit add the follwing into project/build.sbt:\nval izumi_version = \"0.6.0-SNAPSHOT\"\n// sbt toolkit\naddSbtPlugin(\"com.github.pshirshov.izumi.r2\" % \"sbt-izumi\" % izumi_version)\n\n// This is a Izumi's Bill of Materials, see below\naddSbtPlugin(\"com.github.pshirshov.izumi.r2\" % \"sbt-izumi-deps\" % izumi_version)\n\n// idealingua compiler\naddSbtPlugin(\"com.github.pshirshov.izumi.r2\" % \"sbt-idealingua\" % izumi_version)\nTODO Put list of modules here\nYou may find ScalaDoc API docs here","title":"Dependencies"},{"location":"/manifesto/index.html","text":"","title":"Our approach to productivity"},{"location":"/manifesto/index.html#our-approach-to-productivity","text":"TODO Sorry, this page is not ready yet","title":"Our approach to productivity"},{"location":"/pper/index.html","text":"","title":"PPER Pattern"},{"location":"/pper/index.html#pper-pattern","text":"TODO Sorry, this page is not ready yet","title":"PPER Pattern"},{"location":"/distage/index.html","text":"","title":"DiStage DI"},{"location":"/distage/index.html#distage-di","text":"TODO Sorry, this page is not ready yet","title":"DiStage DI"},{"location":"/idealingua/index.html","text":"","title":"Idealingua DML/IDL"},{"location":"/idealingua/index.html#idealingua-dml-idl","text":"The following examples will show what IdeaLingua looks like and how to use.","title":"Idealingua DML/IDL"},{"location":"/idealingua/index.html#language-reference","text":"","title":"Language Reference"},{"location":"/idealingua/index.html#keywords-and-aliases","text":"Keyword Aliases Explanation domain package, namespace Namespace containing collection of entities import References a domain by id include Includes *.model file by name alias type, using Type alias enum Enumeration mixin interface Mixin, named collection of fields data dto, struct Data adt choice Algebraic Data Type id Identifier, named collection of scalars service Service interface def fn, func, fun Method","title":"Keywords and aliases"},{"location":"/idealingua/index.html#inheritance-operators","text":"Keyword Aliases Explanation Example + +++, ... Inherit structure (copy fields) + Mixin & &&& Inherit interface & Mixin - --- Drop structure (doesn’t work for interfaces) - Mixin, - field: str","title":"Inheritance operators"},{"location":"/idealingua/index.html#embedded-data-types","text":"Notes\nWhen it’s impossible to represent a numeric type with target language we use minimal numeric type with bigger range When it’s not possible to represent time type or UUID with target language we use string representation","title":"Embedded data types"},{"location":"/idealingua/index.html#scalar-types","text":"Type name Aliases Explanation Scala mapping str string String String bool boolean, bit Boolean Boolean i08 byte, int8 8-bit integer Byte i16 short, int16 16-bit integer Short i32 int, int32 32-bit integer Int i64 long, int64 64-bit integer Long f32 float, flt Single precision floating point Float f64 double, dbl Double precision floating point Double uid uuid UUID java.util.UUID tsz dtl, datetimel Timestamp with timezone java.time.ZonedDateTime tsl dtz, datetimez Local timestamp java.time.LocalDateTime time time Time java.time.LocalTime date date Date java.time.LocalDate","title":"Scalar types"},{"location":"/idealingua/index.html#generics","text":"Type name Explanation Scala mapping list[T] List List map[K, V] Map (only scalar keys supported) Map opt[T] Optional value Option set[T] Set (no guarantees for traversal ordering) Set","title":"Generics"},{"location":"/idealingua/index.html#standalone-compiler","text":"The compiler is built as an uberjar and published onto central.\nYou may use https://github.com/coursier/coursier to run it:\n# release\ncoursier launch com.github.pshirshov.izumi.r2:idealingua-compiler_2.12:0.5.0 -- --help\n\n# snapshot\ncoursier launch -r https://oss.sonatype.org/content/repositories/snapshots/ com.github.pshirshov.izumi.r2:idealingua-compiler_2.12:0.5.0-SNAPSHOT -- --help\nCommandline examples:\ncoursier launch com.github.pshirshov.izumi.r2:idealingua-compiler_2.12:0.5.0 -- -s src -t target -L scala=* -L typescript=*\ncoursier launch com.github.pshirshov.izumi.r2:idealingua-compiler_2.12:0.5.0 -- -s src -t target -L scala=-AnyvalExtension -L typescript=*","title":"Standalone compiler"},{"location":"/idealingua/index.html#http4s-transport","text":"Most likely you would need to use Kind Projector compiler plugin and partial unification enabled:\nscalacOptions += \"-Ypartial-unification\"\nresolvers += Resolver.sonatypeRepo(\"releases\")\naddCompilerPlugin(\"org.spire-math\" % \"kind-projector\" % \"0.9.6\" cross CrossVersion.binary)\nYou may find a test for the whole http4s pipeline here. Please note that service definitons for that test are implemented manually, you may find them here.","title":"Http4s Transport"},{"location":"/idealingua/cogen.html","text":"","title":"Code generator reference"},{"location":"/idealingua/cogen.html#code-generator-reference","text":"Notes:\nAll the examples are given in minimal form Omitted things: marshallers, implicit conversions, type info\nWe support the following concepts:\nEnumerations Algebraic Data Types Type aliases Mixins Data Classes Identifiers Services","title":"Code generator reference"},{"location":"/idealingua/cogen.html#inheritance","text":"We support two forms of inheritance: interface inheritance (& modifier) and structural mixins (* modifier) The only difference between structural inheritance and interface inheritance is presence/absence of the base interface in the list of supertypes Both Data Classes and Mixins support both forms of inheritance Services, ADTs, Type Aliases, Identifiers and Enumerations does not support inheritance We provide widening narrowing implicit functions as well as copy constructors for all the generated entities","title":"Inheritance"},{"location":"/idealingua/cogen.html#example","text":"mixin IntPair {\n  x: i32\n  y: i32\n}\n\nmixin Metadata {\n  id: str\n  name: str\n}\n\nmixin PointLike {\n  + Metadata\n  * IntPair\n}\n\ndata Point {\n  + Metadata\n  * IntPair\n}","title":"Example"},{"location":"/idealingua/cogen.html#scala-output","text":"trait IntPair {\n  def y: Int\n  def x: Int\n}\n\ntrait Metadata {\n  def name: String\n  def id: String\n}\n\nfinal case class Point(y: Int, name: String, x: Int, id: String) extends Metadata\n\ntrait PointLike extends Metadata {\n  def y: Int\n  def x: Int\n  def name: String\n  def id: String\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#mixin-mixin","text":"mixin Person {\n   name: str\n   surname: str\n }","title":"mixin: Mixin"},{"location":"/idealingua/cogen.html#scala-output","text":"trait Person {\n  def name: String\n  def surname: String\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#data-data-class","text":"Differences between Mixins and Data Classes:\nData class cannot define fields Data class cannot be subclassed Data class is always redered as DTO/case class, Mixin is always rendered as pair of an Interface and an Implementation\ndata HumanUser {\n   + IdentifiedUser\n   * Person\n }","title":"data: Data Class"},{"location":"/idealingua/cogen.html#scala-output","text":"final case class HumanUser(name: String, surname: String, id: UserId) extends IdentifiedUser with Person","title":"Scala output"},{"location":"/idealingua/cogen.html#adt-algebraic-data-type","text":"mixin Success {\n   values: map[str, str]\n }\n \n mixin Failure {\n   message: str\n }\n \n adt Result {\n   Success\n   Failure\n }","title":"adt: Algebraic Data Type"},{"location":"/idealingua/cogen.html#scala-output","text":"trait Failure extends Any { def message: String }\n\ntrait Success extends Any { def values: scala.collection.immutable.Map[String, String] }\n\nsealed trait Result \n\nobject Result {\n  type Element = Result\n  \n  case class Success(value: Success) extends Result\n  case class Failure(value: Failure) extends Result\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#alias-type-alias","text":"alias UserId = str","title":"alias: Type Alias"},{"location":"/idealingua/cogen.html#scala-output","text":"package object domain01 {\ntype UserId = String\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#enum-enumeration","text":"enum Gender {\n  MALE\n  FEMALE\n}","title":"enum: Enumeration"},{"location":"/idealingua/cogen.html#scala-output","text":"sealed trait Gender\n\nobject Gender {\n  type Element = Gender\n  def all: Seq[Gender] = Seq(MALE, FEMALE)\n  def parse(value: String) = value match {\n    case \"MALE\" => MALE\n    case \"FEMALE\" => FEMALE\n  }\n  case object MALE extends Gender { override def toString: String = \"MALE\" }\n  case object FEMALE extends Gender { override def toString: String = \"FEMALE\" }\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#id-identifier","text":"Notes: 1. You can use only scalar builtin types for identifier fields 2. We provide both parser and sane .toString implementation 3. .toString uses the following format: Name#urlencoded(part1):urlencoded(part2):... 4. Fields are sorted by name before using in parser and .toString\nid UserId {\n  value: uid\n  company: uid\n}","title":"id: Identifier"},{"location":"/idealingua/cogen.html#scala-output","text":"final case class UserId(value: java.util.UUID, company: java.util.UUID) {\n  override def toString: String = {\n    import com.github.pshirshov.izumi.idealingua.runtime.model.IDLIdentifier._\n    val suffix = Seq(this.company, this.value).map(part => escape(part.toString)).mkString(\":\")\n    s\"UserId#$suffix\"\n  }\n}\n\nobject UserId {\n  def parse(s: String): UserId = {\n    import com.github.pshirshov.izumi.idealingua.runtime.model.IDLIdentifier._\n    val withoutPrefix = s.substring(s.indexOf(\"#\") + 1)\n    val parts = withoutPrefix.split(\":\").map(part => unescape(part))\n    UserId(parsePart[java.util.UUID](parts(0), classOf[java.util.UUID]), parsePart[java.util.UUID](parts(1), classOf[java.util.UUID]))\n  }\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#service-service","text":"id RecordId {\n  value: uid\n}\n\nmixin WithRecordId {\n  id: RecordId\n}\n\nmixin WithResult {\n  result: shared.rpc#Result\n}\n\nmixin UserData {\n  email: str\n}\n\nmixin PrivateUserData {\n  balance: dbl\n}\n\nservice UserService {\n  def deleteUser(WithRecordId): (WithResult)\n  def createUser(UserData, PrivateUserData): (WithRecordId, WithResult)\n}\nNotes: 1. Service signature cannot accept anything except of Mixins (improvements planned) 2. ServerDispatcher allows you to route wrapped result type to an appropriate method of an abstract implementation 3. ClientDispatcher just passes input to an abstract receiver 4. ClientWrapper allows you to transform unwrapped method signatures into wrapping instances 5. ServerWrapped provides you an unwrapping service implementation 6. ServiceUnwrapped provides you a way to implement services with signatures unwrapped","title":"service: Service"},{"location":"/idealingua/cogen.html#scala-output","text":"import _root_.com.github.pshirshov.izumi.idealingua.model._\nimport _root_.com.github.pshirshov.izumi.idealingua.runtime._\n\nclass UserServiceServerDispatcher[R[+_], S <: UserService[R]](val service: S) extends transport.AbstractServerDispatcher[R, S] {\n  import UserService._\n  override def dispatch(input: UserService.InUserService): R[UserService.OutUserService] = input match {\n    case value: UserService.InDeleteUser =>\n      service.deleteUser(value)\n    case value: UserService.InCreateUser =>\n      service.createUser(value)\n  }\n}\n\nclass UserServiceClientDispatcher[R[+_], S <: UserService[R]](dispatcher: transport.AbstractClientDispatcher[R, S]) extends UserService[R] {\n  import UserService._\n  def deleteUser(input: UserService.InDeleteUser): Result[UserService.OutDeleteUser] = dispatcher.dispatch(input, classOf[UserService.OutDeleteUser])\n  def createUser(input: UserService.InCreateUser): Result[UserService.OutCreateUser] = dispatcher.dispatch(input, classOf[UserService.OutCreateUser])\n}\n\nclass UserServiceClientWrapper[R[+_], S <: UserService[R]](val service: S) extends model.IDLClientWrapper[R, S] {\n  import UserService._\n  def deleteUser(id: RecordId): Result[UserService.OutDeleteUser] = {\n    service.deleteUser(UserService.InDeleteUser(id = id))\n  }\n  def createUser(balance: Double, email: String): Result[UserService.OutCreateUser] = {\n    service.createUser(UserService.InCreateUser(balance = balance, email = email))\n  }\n}\n\ntrait UserServiceUnwrapped[R[+_], S <: UserService[R]] extends model.IDLServiceExploded[R, S] {\n  import UserService._\n  def deleteUser(id: RecordId): Result[UserService.OutDeleteUser]\n  def createUser(balance: Double, email: String): Result[UserService.OutCreateUser]\n}\n\nclass UserServiceServerWrapper[R[+_], S <: UserService[R]](val service: UserServiceUnwrapped[R, S]) extends UserService[R] {\n  import UserService._\n  def deleteUser(input: UserService.InDeleteUser): Result[UserService.OutDeleteUser] = service.deleteUser(id = input.id)\n  def createUser(input: UserService.InCreateUser): Result[UserService.OutCreateUser] = service.createUser(balance = input.balance, email = input.email)\n}\n\ntrait UserService[R[_]] extends com.github.pshirshov.izumi.idealingua.runtime.model.IDLService[R] {\n  import UserService._\n  override type InputType = UserService.InUserService\n  override type OutputType = UserService.OutUserService\n  \n  override def inputClass: Class[UserService.InUserService] = classOf[UserService.InUserService]\n  override def outputClass: Class[UserService.OutUserService] = classOf[UserService.OutUserService]\n  \n  def deleteUser(input: UserService.InDeleteUser): Result[UserService.OutDeleteUser]\n  def createUser(input: UserService.InCreateUser): Result[UserService.OutCreateUser]\n}\n\nobject UserService {\n  sealed trait InUserService extends Any \n  sealed trait OutUserService extends Any\n\n  case class InDeleteUser(id: RecordId) extends UserService.InUserService with WithRecordId\n  case class OutDeleteUser(result: shared.rpc.Result) extends AnyVal with UserService.OutUserService with WithResult\n  case class InCreateUser(balance: Double, email: String) extends UserService.InUserService with UserData with PrivateUserData\n  case class OutCreateUser(result: shared.rpc.Result, id: RecordId) extends UserService.OutUserService with WithRecordId with WithResult\n}","title":"Scala output"},{"location":"/idealingua/cogen-circe.html","text":"","title":"Circe serialization reference"},{"location":"/idealingua/cogen-circe.html#circe-serialization-reference","text":"","title":"Circe serialization reference"},{"location":"/idealingua/cogen-circe.html#polymorphism-and-time","text":"Notes: 1. Data classes cannot be polymorphic\nThe following example demonstrates how polymorphism and time values are handled:\nimport java.time._\n\nimport io.circe._\nimport io.circe.parser._\nimport io.circe.syntax._\nimport io.circe.generic.semiauto._\nimport io.circe.generic.decoding._\nimport io.circe.generic.encoding._\nimport io.circe.java8.time._\n\ntrait Polymorphic\n\nfinal case class TestPayload(\n                        zonedDateTime: ZonedDateTime = ZonedDateTime.now()\n                        , utcZonedDateTime: ZonedDateTime = ZonedDateTime.now(ZoneId.of(\"UTC\"))\n                        , localDateTime: LocalDateTime = LocalDateTime.now()\n                        , localTime: LocalTime = LocalTime.now()\n                        , localDate: LocalDate = LocalDate.now()\n                      ) extends Polymorphic\n\nobject TestPayload {\n  implicit val encodeTestPayload: Encoder[TestPayload] = deriveEncoder[TestPayload]\n  implicit val decodeTestPayload: Decoder[TestPayload] = deriveDecoder[TestPayload]\n}\n\nfinal case class AnotherPayload(message: String) extends Polymorphic\n\nobject AnotherPayload {\n  implicit val encodeAnotherPayload: Encoder[AnotherPayload] = deriveEncoder[AnotherPayload]\n  implicit val decodeAnotherPayload: Decoder[AnotherPayload] = deriveDecoder[AnotherPayload]\n}\n\nobject Polymorphic {\n    implicit val encodePolymorphic: Encoder[Polymorphic] = Encoder.instance { c =>\n    c match {\n      case v: TestPayload =>\n        Map(\"com.test#TestPayload\" -> v).asJson\n      case v: AnotherPayload =>\n        Map(\"com.test#RealPayload\" -> v).asJson\n    }\n  }\n  implicit val decodePolymorphic: Decoder[Polymorphic] = Decoder.instance(c => {\n    val fname = c.keys.flatMap(_.headOption).toSeq.head\n    val value = c.downField(fname)\n    fname match {\n      case \"com.test#TestPayload\" =>\n        value.as[TestPayload]\n      case \"com.test#RealPayload\" =>\n        value.as[AnotherPayload]\n    }\n  })\n}\n\ndef test(t: Polymorphic): Unit = {\n  val encoded = t.asJson.noSpaces\n  println(s\"Encoded:\\n$encoded\\n\")\n  val parsed = parse(encoded)\n  println(s\"Parsed:\\n$parsed\\n\")\n  val restored = parsed.map(_.as[Polymorphic])\n  println(s\"Restored:\\n$restored\\n\")\n}\n\ntest(TestPayload())\ntest(AnotherPayload(\"hi\"))\nThis example produces the following output:\nTestPayload:\nEncoded:\n{\"TestPayload\":{\"zonedDateTime\":\"2018-04-02T22:34:31.367649+01:00[Europe/Dublin]\",\"utcZonedDateTime\":\"2018-04-02T21:34:31.367744Z[UTC]\",\"localDateTime\":\"2018-04-02T22:34:31.36778\",\"localTime\":\"22:34:31.367813\",\"localDate\":\"2018-04-02\"}}\n\nParsed:\nRight({\n  \"TestPayload\" : {\n    \"zonedDateTime\" : \"2018-04-02T22:34:31.367649+01:00[Europe/Dublin]\",\n    \"utcZonedDateTime\" : \"2018-04-02T21:34:31.367744Z[UTC]\",\n    \"localDateTime\" : \"2018-04-02T22:34:31.36778\",\n    \"localTime\" : \"22:34:31.367813\",\n    \"localDate\" : \"2018-04-02\"\n  }\n})\n\nRestored:\nRight(Right(TestPayload(2018-04-02T22:34:31.367649+01:00[Europe/Dublin],2018-04-02T21:34:31.367744Z[UTC],2018-04-02T22:34:31.367780,22:34:31.367813,2018-04-02)))\n\n\nAnotherPayload:\nEncoded:\n{\"RealPayload\":{\"message\":\"hi\"}}\n\nParsed:\nRight({\n  \"RealPayload\" : {\n    \"message\" : \"hi\"\n  }\n})\n\nRestored:\nRight(Right(AnotherPayload(hi)))","title":"Polymorphism and time"},{"location":"/idealingua/cogen-circe.html#algebraic-types","text":"Notes: 1. Works same way as polymorphic types 2. Use short names instead of fully qualified names 3. You may introduce a local alias for an algebraic type member: adt MyAdt { domain1.A as A1 | A}. This allows you to resolve name conflicts\nCogen example for ADTs:\nimport java.time._\n\nimport io.circe._\nimport io.circe.parser._\nimport io.circe.syntax._\nimport io.circe.generic.semiauto._\nimport io.circe.generic.decoding._\nimport io.circe.generic.encoding._\nimport io.circe.java8.time._\n\nsealed trait Algebraic\n\nobject NS1 {\n\n  case class Payload(localTime: LocalTime = LocalTime.now()) extends Algebraic\n\n  object Payload {\n    implicit val encodeTestPayload: Encoder[Payload] = deriveEncoder[Payload]\n    implicit val decodeTestPayload: Decoder[Payload] = deriveDecoder[Payload]\n  }\n\n}\n\nobject NS2 {\n\n  case class AnotherPayload(message: String) extends Algebraic\n\n  object AnotherPayload {\n    implicit val encodeAnotherPayload: Encoder[AnotherPayload] = deriveEncoder[AnotherPayload]\n    implicit val decodeAnotherPayload: Decoder[AnotherPayload] = deriveDecoder[AnotherPayload]\n  }\n\n}\nobject Algebraic {\n  implicit val encodePolymorphic: Encoder[Algebraic] = deriveEncoder[Algebraic]\n  implicit val decodePolymorphic: Decoder[Algebraic] = deriveDecoder[Algebraic]\n}\n\ndef test(t: Algebraic): Unit = {\n  val encoded = t.asJson.noSpaces\n  println(s\"Encoded:\\n$encoded\\n\")\n  val parsed = parse(encoded)\n  println(s\"Parsed:\\n$parsed\\n\")\n  val restored = parsed.map(_.as[Algebraic])\n  println(s\"Restored:\\n$restored\\n\")\n}\n\ntest(NS1.Payload())\ntest(NS2.AnotherPayload(\"hi\"))\nOutput:\nEncoded:\n{\"Payload\":{\"localTime\":\"18:13:31.942072\"}}\n\nParsed:\nRight({\n  \"Payload\" : {\n    \"localTime\" : \"18:13:31.942072\"\n  }\n})\n\nRestored:\nRight(Right(Payload(18:13:31.942072)))\n\nEncoded:\n{\"AnotherPayload\":{\"message\":\"hi\"}}\n\nParsed:\nRight({\n  \"AnotherPayload\" : {\n    \"message\" : \"hi\"\n  }\n})\n\nRestored:\nRight(Right(AnotherPayload(hi)))","title":"Algebraic types"},{"location":"/idealingua/cogen-circe.html#identifiers","text":"Identifiers codec just invokes .toString and .parse to serialize/deserialize Identifiers.\nPlease check identifier codegen example for additional details.\nFull example:\nfinal case class CompanyId(value: java.util.UUID) {\n  override def toString: String = {\n    import com.github.pshirshov.izumi.idealingua.runtime.model.IDLIdentifier._\n    val suffix = Seq(this.value).map(part => escape(part.toString)).mkString(\":\")\n    s\"CompanyId#$suffix\"\n  }\n}\n\ntrait CompanyIdCirce {\n  import _root_.io.circe.{ Encoder, Decoder }\n  implicit val encodeCompanyId: Encoder[CompanyId] = Encoder.encodeString.contramap(_.toString)\n  implicit val decodeCompanyId: Decoder[CompanyId] = Decoder.decodeString.map(CompanyId.parse)\n}\n\nobject CompanyId extends CompanyIdCirce {\n  def parse(s: String): CompanyId = {\n    import com.github.pshirshov.izumi.idealingua.runtime.model.IDLIdentifier._\n    val withoutPrefix = s.substring(s.indexOf(\"#\") + 1)\n    val parts = withoutPrefix.split(\":\").map(part => unescape(part))\n    CompanyId(parsePart[java.util.UUID](parts(0), classOf[java.util.UUID]))\n  }\n  implicit class CompanyIdExtensions(_value: CompanyId)\n}","title":"Identifiers"},{"location":"/idealingua/cogen-circe.html#enumerations","text":"Identifiers codec just invokes .toString and .parse same way as it implemented for Identifiers.","title":"Enumerations"},{"location":"/logstage/index.html","text":"","title":"Logstage"},{"location":"/logstage/index.html#logstage","text":"","title":"Logstage"},{"location":"/logstage/index.html#","text":"","title":"Logging contexts"},{"location":"/logstage/index.html#","text":"","title":"Available sink backends"},{"location":"/logstage/index.html#","text":"","title":"Rendering policy"},{"location":"/logstage/index.html#","text":"","title":"Configuration"},{"location":"/logstage/index.html#","text":"","title":"Examples"},{"location":"/sbt/index.html","text":"","title":"SBT Toolkit"},{"location":"/sbt/index.html#sbt-toolkit","text":"Izumi provides you a bunch of sbt plugins allowing you to significantly reduce size and increase clarity of huge multi-module builds.\nTo start using Izumi plugins add the following into your project/plugins.sbt:\nval izumi_version = \"0.6.0-SNAPSHOT\"\naddSbtPlugin(\"com.github.pshirshov.izumi.r2\" % \"sbt-izumi\" % izumi_version)\n// This is a Izumi's Bill of Materials, see below\naddSbtPlugin(\"com.github.pshirshov.izumi.r2\" % \"sbt-izumi-deps\" % izumi_version)\nWe provide you the following kinds of plugins:\nGlobal Plugin: adds some convenience helpers, activated automatically, Environmental Plugin: changes some aspects of sbt behavior in opinioneted way, intended to be activated within root project, Preset - an opinionated set of environmental plugins, Optional plugin: provides you some convenience tasks, intended to be activated manually, per-project.\nImportant notes:\nPlease keep in mind no plugins are being activated automatically, The rest of Izumi plugins are optional. You may use a preset to activate them or combine them manually as you wish (using settings groups), Some plugins requires to be installed for each project so cannot be activated via preset due to sbt limitations. You should use Settings Groups in order to activate them.","title":"SBT Toolkit"},{"location":"/sbt/index.html#global-plugins","text":"Plugin Description IzumiImportsPlugin Makes all the Izumi imports visible by default","title":"Global plugins"},{"location":"/sbt/index.html#environmental-plugins","text":"Plugin Description IzumiBuildManifestPlugin Adds build info into jar manifests IzumiConvenienceTasksPlugin Devops/workflow helpers IzumiDslPlugin Compact build definitions IzumiGitStampPlugin Adds GIT status into jar manifests IzumiPropertiesPlugin Convenience helpers for sys.props IzumiResolverPlugin Better defaults for artifact resolution IzumiInheritedTestScopesPlugin Convenience helpers for test scope inheritance","title":"Environmental plugins"},{"location":"/sbt/index.html#presets","text":"Plugin Description IzumiEnvironment All the environmental plugins except of GIT one IzumiGitEnvironment All the environmental plugins with GIT one","title":"Presets"},{"location":"/sbt/index.html#optional-plugins","text":"Plugin Description IzumiExposedTestScopesPlugin Maintains test scope separation IzumiCompilerOptionsPlugin Some linting/optimization presets for scalac/javac IzumiFetchPlugin Allows you to transitively download artifacts from remote repositories IzumiPublishingPlugin Some convenience helpers and improvements for artifact publishing IzumiBuildInfoPlugin Generates Bills of Materials","title":"Optional Plugins"},{"location":"/sbt/index.html#installation","text":"To activate all the plugins add the following statements into your root project:\nenablePlugins(IzumiGitEnvironmentPlugin)\nIn case you don’t use GIT, use this preset:\nenablePlugins(IzumiEnvironmentPlugin)\nAlso most likely you would like to activate the following plugins with your global Settings Group:\nval GlobalSettings = new DefaultSettingsGroup {\n  // ...\n}","title":"Installation"},{"location":"/sbt/index.html#inherited-test-scopes","text":"","title":"Inherited Test Scopes"},{"location":"/sbt/index.html#test-scope-inheritance","text":"IzumiScopesPlugin extends SBT Project with several implicit methods:\ntestOnlyRef - provides you a project reference which is equivalent to % \"test\" dependency, dependsSeq and depends - allow you to add dependencies to your project the way test scopes of your dependencies are visible within test scopes of your project. So, essentially when you use these methods your dependencies are added into your projects with the following qualifier: \"test->compile,test;it->compile,test,it\"\nYou need to activate DefaultItSettingsGroup on your projects (see “Setting Groups” below) in order to make this working on it scope.\nExample:\nlazy val myLibrary = ...\n\nlazy val myProject = (...).depends(myLibrary)\nSo, now you may use classes from the test scope of myLibrary within test scope of myProject","title":"Test Scope Inheritance"},{"location":"/sbt/index.html#test-scope-separation","text":"InheritedTestScopesPlugin works in pair with IzumiScopesPlugin and provides you an unique feature: only the classes you marked with @ExposedTestScope are being exposed to dependant artifacts.\nSo, let’s assume that: - you have two artifacts, Library and App, - App depends on Library, - In the test scope of Library you have a class named TestSuite, - In the test scope of Library you have another class named TestUtil, - TestUtil is marked with @ExposedTestScope anotation,\nin that case you may use @TestUtil in the test scope of App, but TestSuite would not be visible.\nA diagram:\n+-----------------------------------------+     +-----------------------------------------+\n| Library                                 |     | App                                     |\n|-----------------------------------------|     |-----------------------------------------|\n| Main scope                              |     | Main scope                              |\n|                                     <---+-----+--                                       |\n| UtilityClass                            |     | AppMain                                 |\n|-----------------------------------------|     |-----------------------------------------+\n| Private Test Scope | Exposed test scope |     | Test scope                              |\n|                    |                <---+-----+--                                       |\n| TestSuite          | TestUtil           |     | Private Test Scope | Exposed test scope |\n+-----------------------------------------+     +-----------------------------------------+\nNotes:\nIDEA doesn’t support overriden classpaths so when you run your tests under IDEA the whole test scopes are visible in dependencies, At the moment the implementation of @ExposedTestScope (substring presence check) is imperfect and has to be improved, Transitive dependencies are not checked, so in case you expose a class but didn’t expose it’s dependencies your build would work under IDEA but you will get a weird and obscure classloading exception running your tests under IDEA. This is going to improved in future.","title":"Test Scope Separation"},{"location":"/sbt/index.html#test-scope-publishing","text":"The whole content of test scopes is being published by default with test qualifier. Test scope separation has no effect on test scope publishing.","title":"Test Scope Publishing"},{"location":"/sbt/index.html#settings-dsl","text":"IzumiDslPlugin provides you a DSL inteded to simplify definitions of complex project layouts.\nTo activate the plugin add the following statement into your root project:\nenablePlugins(IzumiDslPlugin)","title":"Settings DSL"},{"location":"/sbt/index.html#simplified-identifiers","text":"","title":"Simplified Identifiers"},{"location":"/sbt/index.html#setting-groups","text":"","title":"Setting Groups"},{"location":"/sbt/index.html#global-setting-group","text":"","title":"Global Setting Group"},{"location":"/sbt/index.html#automatic-aggregation","text":"When you use .as.project or .as.module syntax to define a project, that project is stored in a global singleton.\nYou may use transitiveAggregate or transitiveAggregateSeq methods instead of standard aggregate, in that case all the transitive dependencies of the projects provided will be also added into aggregation list. This allows you to simplify your definitions by avoiding specifing all the modules in .aggregate.\nIn case you don’t want your project to be recorded, you shoud use .as.just syntax.\nImportant note: sbt is lazy! We just store project reference in a singleton list, we don’t analyze dependency graph. Though sbt relies on lazy val declarations. So, in fact the singleton initializes at the moment you invoke aggregation. In case you don’t add a project into aggregation list such a project still will be initialized by sbt and added into the singleton, but it would happen later than evaluation of aggregation list so the project will not be aggregated.","title":"Automatic Aggregation"},{"location":"/sbt/index.html#aggregation-safety-check","text":"When you invoke transitiveAggregate or transitiveAggregateSeq on your root project it checks if the accumulated set of known project is the same as the set of project loaded by sbt.\nIn case of discrepancies you will get a warning. So in case you use automatic aggregation it’s unlikely that you may accidentally forget to aggregate a module of a multi-module project.","title":"Aggregation Safety Check"},{"location":"/sbt/index.html#build-descriptors","text":"","title":"Build Descriptors"},{"location":"/sbt/index.html#bills-of-materials","text":"","title":"Bills of Materials"},{"location":"/sbt/index.html#build-manifest-entries","text":"","title":"Build Manifest entries"},{"location":"/sbt/index.html#git-manifest-entries","text":"GitStampPlugin adds the following values into MANIFEST.MF of each jar artifact produced:\nManifest Key Description X-Git-Branch The name of branch sbt was invoked on X-Git-Repo-Is-Clean true or false, indicates if GIT repo was in clean state when the build was invoked X-Git-Head-Rev GIT revision on which sbt was invoked\nTo activate the plugin add the following statement into your root project:\nenablePlugins(GitStampPlugin)","title":"Git Manifest entries"},{"location":"/sbt/index.html#convenience-helpers","text":"","title":"Convenience Helpers"},{"location":"/sbt/index.html#stub-generators","text":"ConvenienceTasksPlugin provides you the following commands:\nnewModule <module_path/module_name> [package.suffix]: creates empty project layout at /module_path/module_name. Optional package.suffix may be specified. newStub <module_path/module_name> [stub_name:default]: copies /stubs/${stub_name} into /module_path/module_name. stub_name may be omitted, default value is default\nSetting Description ConvenienceTasksPlugin.Keys.mkJavaDirs Adds src/*/java paths into generated stubs ConvenienceTasksPlugin.Keys.defaultStubPackage Default stub package (sbt.Keys.organization in ThisBuild).value","title":"Stub Generators"},{"location":"/sbt/index.html#version-suffixes","text":"ConvenienceTasksPlugin provides you command\naddVersionSuffix SUFFIX\nThis command updates project version defined in version.sbt with qualifier SUFFIX-SNAPSHOT\nExisting qualifiers will be removed. 1.0.0 would become 1.0.0-SUFFIX-SNAPSHOT 1.0.0-SNAPSHOT would become 1.0.0-SUFFIX-SNAPSHOT\nYou may need this command while setting up a build for feature branches and wish to avoid situation when different branches publishes artifacts with the same names.","title":"Version Suffixes"},{"location":"/sbt/index.html#target-preservation","text":"ConvenienceTasksPlugin provides you command\npreserveTargets SUFFIX\nThis command recursively enumerates all the directories named target and recursively copies them using name target.SUFFIX.\nYou may need this command while setting up a build where you wish to perform clean several times but want to preserve intermediate build artifacts stored in target directories. The most frequent case is coverage build followed by tests and then by production build. In this case you would like to use a command sequence like\n;clean;coverage;test;coverageOff;coverageReport;preserveTargets coverage;clean;publish","title":"target preservation"},{"location":"/sbt/index.html#directory-cleanups","text":"ConvenienceTasksPlugin provides you command\nrmDirs target.coverage\nThis command recursively removes all the directories named target.coverage across the project.\nYou may need this command to cleanup preserved target directories, or destroy some build artifacts, like rmDirs scala-2.11","title":"Directory cleanups"},{"location":"/sbt/index.html#property-readers","text":"IzumiPropertiesPlugin provides you implicit classes allowing you to convert Strings into Integers or Booleans exceptions-safe and do the same for system properties:\n\"true\".asBoolean(default = false) // true\n\"junk\".asBoolean(default = false) // false\n\"123\".asInt(default = 265) // 123\n\"junk\".asInt(default = 265) // 265\nsys.props.asBoolean(\"my.property\", default = false)\nsys.props.asInt(\"my.property\", default = 123)\nYou may activate this plugin with the following statement in root project:","title":"Property Readers"},{"location":"/sbt/index.html#transitive-artifact-downloader","text":"TODO","title":"Transitive Artifact Downloader"},{"location":"/sbt/index.html#optional-settings","text":"","title":"Optional settings"},{"location":"/sbt/index.html#publishing","text":"TODO","title":"Publishing"},{"location":"/sbt/index.html#publishing-settings","text":"TODO","title":"Publishing settings"},{"location":"/sbt/index.html#publishing-credentials-and-targets","text":"TODO","title":"Publishing credentials and targets"},{"location":"/sbt/index.html#compiler-options","text":"CompilerOptionsPlugin provides you some sane compiler option presets (linting, optimizations).\nYou should explicitly enable this plugin in each project you want to use it. When you want to enable it globally, use a settings group:\nval GlobalSettings = new SettingsGroup {\n  override val plugins = Set(\n      CompilerOptionsPlugin,\n      // ...\n  )\n  // ...\n}","title":"Compiler options"},{"location":"/sbt/index.html#resolvers","text":"ResolverPlugin turns on the following settings which should speedup your dependency resolution:\nupdateOptions := updateOptions\n      .value\n      .withCachedResolution(true)\n      .withGigahorse(true)","title":"Resolvers"},{"location":"/logstage/policy.html","text":"","title":"Rendering policy"},{"location":"/logstage/policy.html#rendering-policy","text":"Rendering policy defines how incoming log event will be transformed into a string. Rendering layout defines in a logstage config section. Rendering policy has string interpolator-like format. Each component (named as Log Unit) defines like ${log_unit_label} in string.","title":"Rendering policy"},{"location":"/logstage/policy.html#log-units-specification","text":"Unit Aliases Explanation Syntax timestamp ts Timestamp ${timestamp} thread t Thread data (contains thread name and id) ${thread} level lvl Logging level ${lvl} location loc Log message location (hyperlink to filename it’s line number) ${location} message msg Application-supplied message associated with the logging event ${message} custom-ctx context, ctx User’s context (more info here) ${custom-ctx} exception ex Outputs the stack trace of the exception associated with the logging event, if any. By default the full stack trace will be output. ${ex}","title":"Log units specification"},{"location":"/logstage/policy.html#parameters","text":"Each log unit has parameters. (example, padding, margins, etc). There are common parameters for all log units and specific for each one. NOTE! Currently there are only common parameters (padding). Parameters enumerates in [ ] braces. For example, ${message[15]}\nLog unit Features Explanation Example common padding padding for log unit in result string. It maybe default padding or ellipsed ([:..14]) ${timestamp}[14]","title":"Parameters"},{"location":"/logstage/policy.html#todo-","text":"define params for each log unit provide intuitive syntax for their definition tests!","title":"TODO:"}]}