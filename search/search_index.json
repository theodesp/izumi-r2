{"docs":[{"location":"/index.html","text":"","title":"Izumi Toolkit"},{"location":"/index.html#izumi-toolkit","text":"TODO Sorry, this page is not ready yet\nGithub","title":"Izumi Toolkit"},{"location":"/index.html#dependencies","text":"To use Izumi SBT Toolkit add the follwing into project/build.sbt:\nval izumi_version = \"0.6.0-SNAPSHOT\"\n// sbt toolkit\naddSbtPlugin(\"com.github.pshirshov.izumi.r2\" % \"sbt-izumi\" % izumi_version)\n\n// This is Izumi's BOM (Bill of Materials), see below\naddSbtPlugin(\"com.github.pshirshov.izumi.r2\" % \"sbt-izumi-deps\" % izumi_version)\n\n// idealingua compiler (optional)\naddSbtPlugin(\"com.github.pshirshov.izumi.r2\" % \"sbt-idealingua\" % izumi_version)\nYou can use izumi’s BOM definitions to import (it comes with the sbt-izumi-deps plugin). BOM will insert the correct version automatically:\nlibraryDependencies ++= Seq(\n  \n  // distage\n    Izumi.R.distage_core\n  , Izumi.R.distage_config // Typesafe Config support\n  , Izumi.R.distage_cats // Cats Integration\n  , Izumi.R.distage_static // Compile-time checks & reflection-less mode\n  , Izumi.R.distage_plugins // runtime Plugins support\n  , Izumi.R.distage_app  // DiApp\n  , Izumi.R.logstage_di // LogStage integration\n  \n  // LogStage\n  , Izumi.R.logstage_api_logger\n  , Izumi.R.logstage_adapter_slf4j // Route Slf4J logs to logstage\n  , Izumi.R.logstage_rendering_json4s // dump structured log as JSON\n  , Izumi.R.logstage_sink_console \n  , Izumi.R.logstage_sink_file // write to files with log rotation support\n  , Izumi.R.logstage_sink_slf4j // write to slf4j\n  \n  // Idealingua Runtime Dependencies (for use with Idealingua compiler)\n  , Izumi.R.idealingua_model\n  , Izumi.R.idealingua_runtime_rpc_http4s\n  , Izumi.R.idealingua_runtime_rpc_circe\n  , Izumi.R.idealingua_runtime_rpc_cats\n)\nAlternatively, you can list artifact names and versions manually:\nlibraryDependencies ++= Seq(\n    \"com.github.pshirshov.izumi.r2\" %% \"distage-core\" % \"0.6.0-SNAPSHOT\"\n  , \"com.github.pshirshov.izumi.r2\" %% \"distage-config \" % \"0.6.0-SNAPSHOT\"\n  , \"com.github.pshirshov.izumi.r2\" %% \"distage-cats \" % \"0.6.0-SNAPSHOT\"\n  , \"com.github.pshirshov.izumi.r2\" %% \"distage-static \" % \"0.6.0-SNAPSHOT\"\n  , \"com.github.pshirshov.izumi.r2\" %% \"distage-plugins \" % \"0.6.0-SNAPSHOT\"\n  , \"com.github.pshirshov.izumi.r2\" %% \"distage-app  \" % \"0.6.0-SNAPSHOT\"\n  \n  , \"com.github.pshirshov.izumi.r2\" %% \"logstage-di \" % \"0.6.0-SNAPSHOT\"\n  , \"com.github.pshirshov.izumi.r2\" %% \"logstage-api-logger\" % \"0.6.0-SNAPSHOT\"\n  , \"com.github.pshirshov.izumi.r2\" %% \"logstage-adapter-slf4j \" % \"0.6.0-SNAPSHOT\"\n  , \"com.github.pshirshov.izumi.r2\" %% \"logstage-rendering-json4s \" % \"0.6.0-SNAPSHOT\"\n  , \"com.github.pshirshov.izumi.r2\" %% \"logstage-sink-console \" % \"0.6.0-SNAPSHOT\"\n  , \"com.github.pshirshov.izumi.r2\" %% \"logstage-sink-file \" % \"0.6.0-SNAPSHOT\"\n  , \"com.github.pshirshov.izumi.r2\" %% \"logstage-sink-slf4j \" % \"0.6.0-SNAPSHOT\"\n  \n  , \"com.github.pshirshov.izumi.r2\" %% \"idealingua-model\" % \"0.6.0-SNAPSHOT\"\n  , \"com.github.pshirshov.izumi.r2\" %% \"idealingua-runtime-rpc-http4s\" % \"0.6.0-SNAPSHOT\"\n  , \"com.github.pshirshov.izumi.r2\" %% \"idealingua-runtime-rpc-circe\" % \"0.6.0-SNAPSHOT\"\n  , \"com.github.pshirshov.izumi.r2\" %% \"idealingua-runtime-rpc-cats\" % \"0.6.0-SNAPSHOT\"\n)\nYou may find ScalaDoc API docs here\nYou may find Izumi on github here\nIdeaLingua RPC & Domain Modeling Language User Service Example Pet Store Example Installation Idealingua Language Reference JSON Wire Format Code generator reference Circe serialization reference distage Staged Dependency Injection Hello World Multibindings / Set Bindings Provider Bindings Tagless Final Style with distage Config files Auto-Factories & Auto-Traits Patterns Import Materialization Depending on future values with by-name parameters Ensuring service boundaries using API modules Plugins Roles Test Kit Fixtures and utilities Static Configurations Using Garbage Collector to instantiate only classes required for the test Detailed Feature Overview Implicits Injection Compile-Time Checks Circular Dependencies support Auto-Sets: Collecting Bindings By Predicate Debugging, Introspection, Diagnostics and Hooks Extensions and Plan Rewriting – writing a distage extension Migrating from Guice Migrating from MacWire Integrations Cats Scalaz Freestyle Eff PPER LogStage Overview Dependencies Basic setup Rendering policy logstage/config.html logstage/custom_ctx.html SBT Toolkit Global plugins Environmental plugins Presets Optional plugins Installation Inherited Test Scopes Settings DSL Build Descriptors Convenience Helpers Optional settings Productivity and challenges PPER Pattern","title":"Dependencies"},{"location":"/idealingua/index.html","text":"","title":"IdeaLingua RPC & Domain Modeling Language"},{"location":"/idealingua/index.html#idealingua-rpc-domain-modeling-language","text":"IdeaLingua is an RPC framework & Domain Modeling Language, it’s purpose is to:\nPublish APIs & data definitions in a common format and use them idiomatically in each target language. Enable remote calls to each service via public API definitions. Abstract irrelevant details such as network protocol. Idealingua is protocol-independent and can be used within or without network. Deliver our souls from REST and its brittle boilerplate.\nIf that sounds like just what you need, check out our examples:","title":"IdeaLingua RPC & Domain Modeling Language"},{"location":"/idealingua/index.html#user-service-example","text":"Example definition of a user database service:\npackage user.api\n\nenum Gender = Male | Female\n\nid EntityID {\n  uuid: uuid\n}\n\nmixin Entity {\n  id: EntityID\n}\n\nmixin Person {\n  name: str\n  surname: str\n  gender: Gender\n}\n\ndata User {\n  & Entity\n  + Person\n  password: str\n}\n\ndata PublicUser {\n  + User\n  - password: str\n}\n\nadt Result = Success | Failure\n\ndata Success {\n  message: str\n}\n\ndata Failure {\n  code: int8\n}\n\nservice UserService {\n  def saveUser(user: User): Result\n  def findUserByName(name: str): list[PublicUser] | Failure\n}","title":"User Service Example"},{"location":"/idealingua/index.html#pet-store-example","text":"See izumi-petstore for examples in Scala, TypeScript, Go, C# and other languages.","title":"Pet Store Example"},{"location":"/idealingua/index.html#installation","text":"","title":"Installation"},{"location":"/idealingua/index.html#using-sbt-plugin","text":"Add the following to your project/plugins.sbt file:\nval izumi_version = \"0.6.0-SNAPSHOT\"\naddSbtPlugin(\"com.github.pshirshov.izumi.r2\" % \"sbt-idealingua\" % izumi_version)\nPlace your domain definitions into /src/main/izumi directory, then enable the plugin for that project. For the generated code to compile, you will also need to add dependencies on the Idealingua RTS modules:\nizumiProject\n  .enablePlugins(IdealinguaPlugin)\n  .settings(\n    libraryDependencies ++= Seq(\n        Izumi.R.idealingua_model\n      , Izumi.R.idealingua_runtime_rpc\n      , Izumi.R.idealingua_runtime_rpc_http4s\n      , Izumi.R.idealingua_runtime_rpc_circe\n    )\n  )\nYou can depend on the code generated by Idealinguain in your other Scala projects:\nproject.dependsOn(izumiProject)","title":"Using SBT Plugin"},{"location":"/idealingua/index.html#using-the-standalone-compiler","text":"The compiler executable is built as an uberjar and published on Maven Central.\nThe preferred way to install the compiler is with coursier\n# install release executable\ncoursier bootstrap com.github.pshirshov.izumi.r2:idealingua-compiler_2.12:0.6.0-SNAPSHOT -o idlc\n\n./idlc --help\nTo install snapshot:\n# install snapshot\ncoursier bootstrap -r https://oss.sonatype.org/content/repositories/snapshots/ com.github.pshirshov.izumi.r2:idealingua-compiler_2.12:0.6.0-SNAPSHOT -o idlc\n\n./idlc --help\nCommandline examples:\n./idlc -s src -t target -L scala=* -L typescript=*\n./idlc -s src -t target -L scala=-AnyvalExtension -L typescript=*","title":"Using the standalone compiler"},{"location":"/idealingua/index.html#scala-http4s-transport","text":"Most likely you will need to use Kind Projector compiler plugin and enable partial unification:\nscalacOptions += \"-Ypartial-unification\"\n\nresolvers += Resolver.sonatypeRepo(\"releases\")\n\naddCompilerPlugin(\"org.spire-math\" % \"kind-projector\" % \"0.9.6\" cross CrossVersion.binary)\nYou may find a test suite for the whole http4s pipeline here.\nPlease note that service definitons for the test suite are not generated from Idealingua definitions, you can find the Scala sources here.","title":"Scala http4s Transport"},{"location":"/idealingua/language-reference.html","text":"","title":"Idealingua Language Reference"},{"location":"/idealingua/language-reference.html#idealingua-language-reference","text":"","title":"Idealingua Language Reference"},{"location":"/idealingua/language-reference.html#keywords-and-aliases","text":"Keyword Aliases Explanation domain package, namespace Namespace containing collection of entities import References a domain by id include Includes *.model file by name alias type, using Type alias enum Enumeration mixin interface Mixin, named collection of fields data dto, struct Data adt choice Algebraic Data Type id Identifier, named collection of scalars service Service interface def fn, func, fun Method","title":"Keywords and aliases"},{"location":"/idealingua/language-reference.html#inheritance-operators","text":"Keyword Aliases Explanation Example + +++, ... Inherit structure (copy fields) + Mixin & &&& Inherit interface & Mixin - --- Drop structure or field (doesn’t work for interfaces) - Mixin, - field: str","title":"Inheritance operators"},{"location":"/idealingua/language-reference.html#built-in-types","text":"","title":"Built-in types"},{"location":"/idealingua/language-reference.html#scalars","text":"Type name Aliases Explanation Scala type str string String String bool boolean, bit Boolean Boolean i08 byte, int8 8-bit integer Byte i16 short, int16 16-bit integer Short i32 int, int32 32-bit integer Int i64 long, int64 64-bit integer Long f32 float, flt Single precision floating point Float f64 double, dbl Double precision floating point Double uid uuid UUID java.util.UUID tsz dtl, datetimel Timestamp with timezone java.time.ZonedDateTime tsl dtz, datetimez Local timestamp java.time.LocalDateTime time time Time java.time.LocalTime date date Date java.time.LocalDate\nNotes:\nWhen the target language lacks a corresponding numeric type, we use the smallest type available that includes the required type. i.e. in TypeScript i08 is number When the target language lacks types for time","title":"Scalars"},{"location":"/idealingua/language-reference.html#collections","text":"Type name Explanation Scala mapping list[T] List List map[K, V] Map (only scalar and id keys are supported) Map opt[T] Optional value Option set[T] Set (unordered) Set","title":"Collections"},{"location":"/idealingua/json.html","text":"","title":"JSON Wire Format"},{"location":"/idealingua/json.html#json-wire-format","text":"IdeaLingua employs a simple JSON-based wire format. To interoperate, all the language translators should implement this spec.","title":"JSON Wire Format"},{"location":"/idealingua/json.html#data-data-class","text":"data defined as:\npackage example\n\ndata User {\n  name: str\n  surname: str\n  id: uuid\n}\nShould be rendered as:\n{\n  \"name\": \"Lorem\",\n  \"surname\": \"Ipsum\",\n  \"id\": \"13bee602-521b-47c2-ad81-30527f8b2398\"\n}","title":"data: Data Class"},{"location":"/idealingua/json.html#mixin-mixin","text":"When sent over the wire, mixins include a fully qualified name of their implementation.\nmixins defined as:\npackage example\n\nmixin IntPair {\n  x: i32\n  y: i32\n}\n\ndata NamedIntPair {\n  & IntPair\n  name: str\n}\nShould be rendered as:\n{ \n  \"example.IntPair#Struct\": {\n    \"x\": 256,\n    \"y\": 512\n  }\n}\nfor the default implementation, and:\n{\n  \"example#NamedIntPair\": {\n    \"x\": 256,\n    \"y\": 512,\n    \"name\": \"Vertex\"\n  }\n}\nfor the NamedIntPair implementation.","title":"mixin: Mixin"},{"location":"/idealingua/json.html#adt-algebraic-data-type","text":"adt’s include an unqualified name of their variant.\nadt defined as:\npackage example\n\nadt AB = A | Z as B\n\ndata A {\n  value: i32\n}\n\ndata Z {\n  value: str\n}\nShould be rendered as:\n{\n  \"A\": { \n    \"value\": 1\n  }\n}\nfor the A variant, and:\n{\n  \"B\": {\n    \"value\": \"abc\"\n  }\n}\nfor the Z as B variant","title":"adt: Algebraic Data Type"},{"location":"/idealingua/json.html#id-identifier","text":"Ids are rendered as strings prefixed by type name and separated by : symbol. Field order is preserved.\nid defined as:\npackage example\n\nid UserId {\n  userId: uuid\n  companyName: str\n}\nShould be rendered as:\n\"UserId#837006c8-d070-4cde-a2dd-8999c186ef02:Lightbend\"","title":"id: Identifier"},{"location":"/idealingua/json.html#alias-type-alias","text":"Type Aliases should be rendered directly as their aliased types and should never impact serialization.","title":"alias: Type Alias"},{"location":"/idealingua/json.html#enum-enumeration","text":"Enums are rendered as strings.\nenum defined as:\npackage example\n\nenum Gender = MALE | FEMALE\nShould be rendered as:\n\"FEMALE\"","title":"enum: Enumeration"},{"location":"/idealingua/json.html#service","text":"Service outputs are always wrapped into a JSON object with one field \"value\".\nFor service defined as:\npackage example\n\nservice SayHello {\n  def sayHello(): str\n}\nsayHello method will return a result rendered as:\n{ \"value\": \"hello\" }","title":"Service"},{"location":"/idealingua/cogen.html","text":"","title":"Code generator reference"},{"location":"/idealingua/cogen.html#code-generator-reference","text":"We support the following concepts:\nEnumerations Algebraic Data Types Type aliases Mixins Data Classes Identifiers Services","title":"Code generator reference"},{"location":"/idealingua/cogen.html#inheritance","text":"We support two forms of inheritance: interface inheritance (& modifier) and structural mixins (* modifier) The only difference between structural inheritance and interface inheritance is presence/absence of the base interface in the list of supertypes Both Data Classes and Mixins support both forms of inheritance Services, ADTs, Type Aliases, Identifiers and Enumerations does not support inheritance We provide widening narrowing implicit functions as well as copy constructors for all the generated entities","title":"Inheritance"},{"location":"/idealingua/cogen.html#example","text":"mixin IntPair {\n  x: i32\n  y: i32\n}\n\nmixin Metadata {\n  id: str\n  name: str\n}\n\nmixin PointLike {\n  + Metadata\n  * IntPair\n}\n\ndata Point {\n  + Metadata\n  * IntPair\n}","title":"Example"},{"location":"/idealingua/cogen.html#scala-output","text":"trait IntPair {\n  def y: Int\n  def x: Int\n}\n\ntrait Metadata {\n  def name: String\n  def id: String\n}\n\nfinal case class Point(y: Int, name: String, x: Int, id: String) extends Metadata\n\ntrait PointLike extends Metadata {\n  def y: Int\n  def x: Int\n  def name: String\n  def id: String\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#constructs","text":"Notes:\nAll the examples of generated code are given in minimal form Generated code for codecs, implicit conversions and type info is omitted","title":"Constructs"},{"location":"/idealingua/cogen.html#mixin-mixin","text":"mixin Person {\n   name: str\n   surname: str\n }","title":"mixin: Mixin"},{"location":"/idealingua/cogen.html#scala-output","text":"trait Person {\n  def name: String\n  def surname: String\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#data-data-class","text":"Differences between Mixins and Data Classes:\nData classes cannot be subclassed Data classes are always rendered as case classes, Mixins are always rendered as pair of Interface and Implementation\ndata HumanUser {\n   + IdentifiedUser\n   * Person\n }","title":"data: Data Class"},{"location":"/idealingua/cogen.html#scala-output","text":"final case class HumanUser(name: String, surname: String, id: UserId) extends IdentifiedUser with Person","title":"Scala output"},{"location":"/idealingua/cogen.html#adt-algebraic-data-type","text":"mixin Success {\n   values: map[str, str]\n }\n \n mixin Failure {\n   message: str\n }\n \n adt Result {\n   Success\n   Failure\n }","title":"adt: Algebraic Data Type"},{"location":"/idealingua/cogen.html#scala-output","text":"trait Failure extends Any { def message: String }\n\ntrait Success extends Any { def values: scala.collection.immutable.Map[String, String] }\n\nsealed trait Result \n\nobject Result {\n  type Element = Result\n  \n  case class Success(value: Success) extends Result\n  case class Failure(value: Failure) extends Result\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#alias-type-alias","text":"alias UserId = str","title":"alias: Type Alias"},{"location":"/idealingua/cogen.html#scala-output","text":"package object domain01 {\ntype UserId = String\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#enum-enumeration","text":"enum Gender {\n  MALE\n  FEMALE\n}","title":"enum: Enumeration"},{"location":"/idealingua/cogen.html#scala-output","text":"sealed trait Gender\n\nobject Gender {\n  type Element = Gender\n  def all: Seq[Gender] = Seq(MALE, FEMALE)\n  def parse(value: String) = value match {\n    case \"MALE\" => MALE\n    case \"FEMALE\" => FEMALE\n  }\n  case object MALE extends Gender { override def toString: String = \"MALE\" }\n  case object FEMALE extends Gender { override def toString: String = \"FEMALE\" }\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#id-identifier","text":"Notes:\nYou can use only scalar builtin types for identifier fields We provide both parser and sane .toString implementation .toString uses the following format: Name#urlencoded(part1):urlencoded(part2):... Fields are sorted by name before using in parser and .toString\nid UserId {\n  value: uid\n  company: uid\n}","title":"id: Identifier"},{"location":"/idealingua/cogen.html#scala-output","text":"final case class UserId(value: java.util.UUID, company: java.util.UUID) {\n  override def toString: String = {\n    import com.github.pshirshov.izumi.idealingua.runtime.model.IDLIdentifier._\n    val suffix = Seq(this.company, this.value).map(part => escape(part.toString)).mkString(\":\")\n    s\"UserId#$suffix\"\n  }\n}\n\nobject UserId {\n  def parse(s: String): UserId = {\n    import com.github.pshirshov.izumi.idealingua.runtime.model.IDLIdentifier._\n    val withoutPrefix = s.substring(s.indexOf(\"#\") + 1)\n    val parts = withoutPrefix.split(\":\").map(part => unescape(part))\n    UserId(parsePart[java.util.UUID](parts(0), classOf[java.util.UUID]), parsePart[java.util.UUID](parts(1), classOf[java.util.UUID]))\n  }\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#service-service","text":"id RecordId {\n  value: uid\n}\n\nmixin WithRecordId {\n  id: RecordId\n}\n\nmixin WithResult {\n  result: shared.rpc#Result\n}\n\nmixin UserData {\n  email: str\n}\n\nmixin PrivateUserData {\n  balance: f64\n}\n\nservice UserService {\n  def deleteUser(WithRecordId): (WithResult)\n  def createUser(UserData, PrivateUserData): (WithRecordId, WithResult)\n}\nNotes:\nService signature cannot accept anything except of Mixins (improvements planned) ServerDispatcher allows you to route wrapped result type to an appropriate method of an abstract implementation ClientDispatcher just passes input to an abstract receiver ClientWrapper allows you to transform unwrapped method signatures into wrapping instances ServerWrapped provides you an unwrapping service implementation ServiceUnwrapped provides you a way to implement services with signatures unwrapped","title":"service: Service"},{"location":"/idealingua/cogen.html#scala-output","text":"import _root_.com.github.pshirshov.izumi.idealingua.model._\nimport _root_.com.github.pshirshov.izumi.idealingua.runtime._\n\nclass UserServiceServerDispatcher[R[+_], S <: UserService[R]](val service: S) extends transport.AbstractServerDispatcher[R, S] {\n  import UserService._\n  override def dispatch(input: UserService.InUserService): R[UserService.OutUserService] = input match {\n    case value: UserService.InDeleteUser =>\n      service.deleteUser(value)\n    case value: UserService.InCreateUser =>\n      service.createUser(value)\n  }\n}\n\nclass UserServiceClientDispatcher[R[+_], S <: UserService[R]](dispatcher: transport.AbstractClientDispatcher[R, S]) extends UserService[R] {\n  import UserService._\n  def deleteUser(input: UserService.InDeleteUser): Result[UserService.OutDeleteUser] = dispatcher.dispatch(input, classOf[UserService.OutDeleteUser])\n  def createUser(input: UserService.InCreateUser): Result[UserService.OutCreateUser] = dispatcher.dispatch(input, classOf[UserService.OutCreateUser])\n}\n\nclass UserServiceClientWrapper[R[+_], S <: UserService[R]](val service: S) extends model.IDLClientWrapper[R, S] {\n  import UserService._\n  def deleteUser(id: RecordId): Result[UserService.OutDeleteUser] = {\n    service.deleteUser(UserService.InDeleteUser(id = id))\n  }\n  def createUser(balance: Double, email: String): Result[UserService.OutCreateUser] = {\n    service.createUser(UserService.InCreateUser(balance = balance, email = email))\n  }\n}\n\ntrait UserServiceUnwrapped[R[+_], S <: UserService[R]] extends model.IDLServiceExploded[R, S] {\n  import UserService._\n  def deleteUser(id: RecordId): Result[UserService.OutDeleteUser]\n  def createUser(balance: Double, email: String): Result[UserService.OutCreateUser]\n}\n\nclass UserServiceServerWrapper[R[+_], S <: UserService[R]](val service: UserServiceUnwrapped[R, S]) extends UserService[R] {\n  import UserService._\n  def deleteUser(input: UserService.InDeleteUser): Result[UserService.OutDeleteUser] = service.deleteUser(id = input.id)\n  def createUser(input: UserService.InCreateUser): Result[UserService.OutCreateUser] = service.createUser(balance = input.balance, email = input.email)\n}\n\ntrait UserService[R[_]] extends com.github.pshirshov.izumi.idealingua.runtime.model.IDLService[R] {\n  import UserService._\n  override type InputType = UserService.InUserService\n  override type OutputType = UserService.OutUserService\n  \n  override def inputClass: Class[UserService.InUserService] = classOf[UserService.InUserService]\n  override def outputClass: Class[UserService.OutUserService] = classOf[UserService.OutUserService]\n  \n  def deleteUser(input: UserService.InDeleteUser): Result[UserService.OutDeleteUser]\n  def createUser(input: UserService.InCreateUser): Result[UserService.OutCreateUser]\n}\n\nobject UserService {\n  sealed trait InUserService extends Any \n  sealed trait OutUserService extends Any\n\n  case class InDeleteUser(id: RecordId) extends UserService.InUserService with WithRecordId\n  case class OutDeleteUser(result: shared.rpc.Result) extends AnyVal with UserService.OutUserService with WithResult\n  case class InCreateUser(balance: Double, email: String) extends UserService.InUserService with UserData with PrivateUserData\n  case class OutCreateUser(result: shared.rpc.Result, id: RecordId) extends UserService.OutUserService with WithRecordId with WithResult\n}","title":"Scala output"},{"location":"/idealingua/cogen-circe.html","text":"","title":"Circe serialization reference"},{"location":"/idealingua/cogen-circe.html#circe-serialization-reference","text":"","title":"Circe serialization reference"},{"location":"/idealingua/cogen-circe.html#polymorphism-and-time","text":"Notes:\nData classes cannot be polymorphic\nThe following example demonstrates how polymorphism and time values are handled:\nimport java.time._\n\nimport io.circe._\nimport io.circe.parser._\nimport io.circe.syntax._\nimport io.circe.generic.semiauto._\nimport io.circe.generic.decoding._\nimport io.circe.generic.encoding._\nimport io.circe.java8.time._\n\ntrait Polymorphic\n\nfinal case class TestPayload(\n                        zonedDateTime: ZonedDateTime = ZonedDateTime.now()\n                        , utcZonedDateTime: ZonedDateTime = ZonedDateTime.now(ZoneId.of(\"UTC\"))\n                        , localDateTime: LocalDateTime = LocalDateTime.now()\n                        , localTime: LocalTime = LocalTime.now()\n                        , localDate: LocalDate = LocalDate.now()\n                      ) extends Polymorphic\n\nobject TestPayload {\n  implicit val encodeTestPayload: Encoder[TestPayload] = deriveEncoder[TestPayload]\n  implicit val decodeTestPayload: Decoder[TestPayload] = deriveDecoder[TestPayload]\n}\n\nfinal case class AnotherPayload(message: String) extends Polymorphic\n\nobject AnotherPayload {\n  implicit val encodeAnotherPayload: Encoder[AnotherPayload] = deriveEncoder[AnotherPayload]\n  implicit val decodeAnotherPayload: Decoder[AnotherPayload] = deriveDecoder[AnotherPayload]\n}\n\nobject Polymorphic {\n    implicit val encodePolymorphic: Encoder[Polymorphic] = Encoder.instance { c =>\n    c match {\n      case v: TestPayload =>\n        Map(\"com.test#TestPayload\" -> v).asJson\n      case v: AnotherPayload =>\n        Map(\"com.test#RealPayload\" -> v).asJson\n    }\n  }\n  implicit val decodePolymorphic: Decoder[Polymorphic] = Decoder.instance(c => {\n    val fname = c.keys.flatMap(_.headOption).toSeq.head\n    val value = c.downField(fname)\n    fname match {\n      case \"com.test#TestPayload\" =>\n        value.as[TestPayload]\n      case \"com.test#RealPayload\" =>\n        value.as[AnotherPayload]\n    }\n  })\n}\n\ndef test(t: Polymorphic): Unit = {\n  val encoded = t.asJson.noSpaces\n  println(s\"Encoded:\\n$encoded\\n\")\n  val parsed = parse(encoded)\n  println(s\"Parsed:\\n$parsed\\n\")\n  val restored = parsed.map(_.as[Polymorphic])\n  println(s\"Restored:\\n$restored\\n\")\n}\n\ntest(TestPayload())\ntest(AnotherPayload(\"hi\"))\nThis example produces the following output:\nTestPayload:\nEncoded:\n{\"TestPayload\":{\"zonedDateTime\":\"2018-04-02T22:34:31.367649+01:00[Europe/Dublin]\",\"utcZonedDateTime\":\"2018-04-02T21:34:31.367744Z[UTC]\",\"localDateTime\":\"2018-04-02T22:34:31.36778\",\"localTime\":\"22:34:31.367813\",\"localDate\":\"2018-04-02\"}}\n\nParsed:\nRight({\n  \"TestPayload\" : {\n    \"zonedDateTime\" : \"2018-04-02T22:34:31.367649+01:00[Europe/Dublin]\",\n    \"utcZonedDateTime\" : \"2018-04-02T21:34:31.367744Z[UTC]\",\n    \"localDateTime\" : \"2018-04-02T22:34:31.36778\",\n    \"localTime\" : \"22:34:31.367813\",\n    \"localDate\" : \"2018-04-02\"\n  }\n})\n\nRestored:\nRight(Right(TestPayload(2018-04-02T22:34:31.367649+01:00[Europe/Dublin],2018-04-02T21:34:31.367744Z[UTC],2018-04-02T22:34:31.367780,22:34:31.367813,2018-04-02)))\n\n\nAnotherPayload:\nEncoded:\n{\"RealPayload\":{\"message\":\"hi\"}}\n\nParsed:\nRight({\n  \"RealPayload\" : {\n    \"message\" : \"hi\"\n  }\n})\n\nRestored:\nRight(Right(AnotherPayload(hi)))","title":"Polymorphism and time"},{"location":"/idealingua/cogen-circe.html#algebraic-types","text":"Notes:\nWorks same way as polymorphic types Use short names instead of fully qualified names You may introduce a local alias for an algebraic type member: adt MyAdt { domain1.A as A1 | A}. This allows you to resolve name conflicts\nCogen example for ADTs:\nimport java.time._\n\nimport io.circe._\nimport io.circe.parser._\nimport io.circe.syntax._\nimport io.circe.generic.semiauto._\nimport io.circe.generic.decoding._\nimport io.circe.generic.encoding._\nimport io.circe.java8.time._\n\nsealed trait Algebraic\n\nobject NS1 {\n\n  case class Payload(localTime: LocalTime = LocalTime.now()) extends Algebraic\n\n  object Payload {\n    implicit val encodeTestPayload: Encoder[Payload] = deriveEncoder[Payload]\n    implicit val decodeTestPayload: Decoder[Payload] = deriveDecoder[Payload]\n  }\n\n}\n\nobject NS2 {\n\n  case class AnotherPayload(message: String) extends Algebraic\n\n  object AnotherPayload {\n    implicit val encodeAnotherPayload: Encoder[AnotherPayload] = deriveEncoder[AnotherPayload]\n    implicit val decodeAnotherPayload: Decoder[AnotherPayload] = deriveDecoder[AnotherPayload]\n  }\n\n}\nobject Algebraic {\n  implicit val encodePolymorphic: Encoder[Algebraic] = deriveEncoder[Algebraic]\n  implicit val decodePolymorphic: Decoder[Algebraic] = deriveDecoder[Algebraic]\n}\n\ndef test(t: Algebraic): Unit = {\n  val encoded = t.asJson.noSpaces\n  println(s\"Encoded:\\n$encoded\\n\")\n  val parsed = parse(encoded)\n  println(s\"Parsed:\\n$parsed\\n\")\n  val restored = parsed.map(_.as[Algebraic])\n  println(s\"Restored:\\n$restored\\n\")\n}\n\ntest(NS1.Payload())\ntest(NS2.AnotherPayload(\"hi\"))\nOutput:\nEncoded:\n{\"Payload\":{\"localTime\":\"18:13:31.942072\"}}\n\nParsed:\nRight({\n  \"Payload\" : {\n    \"localTime\" : \"18:13:31.942072\"\n  }\n})\n\nRestored:\nRight(Right(Payload(18:13:31.942072)))\n\nEncoded:\n{\"AnotherPayload\":{\"message\":\"hi\"}}\n\nParsed:\nRight({\n  \"AnotherPayload\" : {\n    \"message\" : \"hi\"\n  }\n})\n\nRestored:\nRight(Right(AnotherPayload(hi)))","title":"Algebraic types"},{"location":"/idealingua/cogen-circe.html#identifiers","text":"Identifiers codec just invokes .toString and .parse to serialize/deserialize Identifiers.\nPlease check identifier codegen example for additional details.\nFull example:\nfinal case class CompanyId(value: java.util.UUID) {\n  override def toString: String = {\n    import com.github.pshirshov.izumi.idealingua.runtime.model.IDLIdentifier._\n    val suffix = Seq(this.value).map(part => escape(part.toString)).mkString(\":\")\n    s\"CompanyId#$suffix\"\n  }\n}\n\ntrait CompanyIdCirce {\n  import _root_.io.circe.{ Encoder, Decoder }\n  implicit val encodeCompanyId: Encoder[CompanyId] = Encoder.encodeString.contramap(_.toString)\n  implicit val decodeCompanyId: Decoder[CompanyId] = Decoder.decodeString.map(CompanyId.parse)\n}\n\nobject CompanyId extends CompanyIdCirce {\n  def parse(s: String): CompanyId = {\n    import com.github.pshirshov.izumi.idealingua.runtime.model.IDLIdentifier._\n    val withoutPrefix = s.substring(s.indexOf(\"#\") + 1)\n    val parts = withoutPrefix.split(\":\").map(part => unescape(part))\n    CompanyId(parsePart[java.util.UUID](parts(0), classOf[java.util.UUID]))\n  }\n  implicit class CompanyIdExtensions(_value: CompanyId)\n}","title":"Identifiers"},{"location":"/idealingua/cogen-circe.html#enumerations","text":"Identifiers codec just invokes .toString and .parse same way as it implemented for Identifiers.","title":"Enumerations"},{"location":"/distage/index.html","text":"","title":"distage Staged Dependency Injection"},{"location":"/distage/index.html#distage-staged-dependency-injection","text":"distage is a pragmatic module system for Scala that combines safety and clarity of pure FP with late binding, flexibility and malleability of runtime dependency injection frameworks such as Guice.","title":"distage Staged Dependency Injection"},{"location":"/distage/index.html#hello-world","text":"This is what Hello World looks like in distage:\nimport distage._\n\nclass Hello {\n  def hello(name: String) = println(s\"Hello $name!\")\n}\n\nobject HelloModule extends ModuleDef {\n  make[Hello]\n}\n\nobject Main extends App {\n  val injector = Injector()\n\n  val plan = injector.plan(HelloModule)\n\n  val classes: Locator = injector.produce(plan)\n\n  println(\"What's your name?\")\n  val name = readLine()\n  \n  classes.get[Hello].hello(name)\n}\nLet’s take a closer look:\nobject HelloModule extends ModuleDef {\n  make[Hello]\n}\nWe define a Module for our application. A module specifies what classes to instantiate and how to instantiate them.\nIn this case we are using the default instantiation strategy - just calling the constructor.\nIf a constructor accepts arguments, distage will first instantiate the arguments, then call the constructor. All the classes in distage are instantiated exactly once, even if multiple different classes depend on them, in other words they are Singletons.\nModules can be combined using ++ and overridenBy operators. For example we can join our HelloModule with a ByeModule:\nobject ByeModule extends ModuleDef {\n  make[Bye]\n}\n\nclass Bye {\n  def bye(name: String) = println(s\"Bye $name!\")\n}\n\nval helloBye = HelloModule ++ ByeModule\nAnd override:\nval uppercaseHello = new Hello { \n  override def hello(name: String) = s\"HELLO ${name.toUpperCase}\"\n}\n\nobject UppercaseHelloModule extends ModuleDef {\n  make[Hello].from(uppercaseHello)  \n}\n\nval uppercaseHelloBye = helloBye overridenBy uppercaseHello\nCombining modules with ++ is the main way to assemble your app together! But, if you don’t want to list all your modules in one place, you can use Plugins to automatically discover all the (marked) modules in your app.\nIf you choose to combine modules explicitly, distage offers compile-time checks ensuring that your app will start. See Static Configurations for details.\nobject Main extends App {\n  val injector = Injector()\n  \n  val plan = injector.plan(HelloModule)\nWe create an instantation plan from the module definition. distage is staged, so instead of instantiating our definitions right away, distage first builds a pure representation of all the operations it will do and returns it back to us.\nThis allows us to easily implement additional functionality on top of distage without modifying the library. Features such as Plugins and Configurations are separate libraries, built on transforming modules and plans\nval classes: Locator = injector.produce(plan)\n\n  classes.get[Hello].helloWorld()\nAfter we execute the plan we’re left a Locator that holds all of our app’s classes. We can retrieve the instances by type using the .get method","title":"Hello World"},{"location":"/distage/index.html#multibindings-set-bindings","text":"Multibindings are useful for implementing event listeners, plugins, hooks, http routes, etc.\nTo define a multibinding use .many and .add methods in ModuleDef DSL:\nimport cats.effect._, org.http4s._, org.http4s.dsl.io._, scala.concurrent.ExecutionContext.Implicits.global\nimport distage._\n\nobject HomeRouteModule extends ModuleDef {\n  many[HttpRoutes[IO]].add {\n    HttpRoutes.of[IO] { case GET -> Root / \"home\" => Ok(s\"Home page!\") }\n  }\n}\nMultibindings defined in different modules will be merged together into a single Set. You can summon a multibinding by type Set[_]:\nimport cats.implicits._, import org.http4s.server.blaze._, import org.http4s.implicits._\n\nobject BlogRouteModule extends ModuleDef {\n  many[HttpRoutes[IO]].add {\n    HttpRoutes.of[IO] { case GET -> Root / \"blog\" / post => Ok(\"Blog post ``$post''!\") }\n  }\n}\n\nclass HttpServer(routes: Set[HttpRoutes[IO]]) {\n  val router = routes.foldK\n\n  def serve = BlazeBuilder[IO]\n    .bindHttp(8080, \"localhost\")\n    .mountService(router, \"/\")\n    .start\n}\n\nval context = Injector().produce(HomeRouteModule ++ BlogRouteModule)\nval server = context.get[HttpServer]\n\nval testRouter = server.router.orNotFound\n\ntestRouter.run(Request[IO](uri = uri(\"/home\"))).flatMap(_.as[String]).unsafeRunSync\n// Home page!\n\ntestRouter.run(Request[IO](uri = uri(\"/blog/1\"))).flatMap(_.as[String]).unsafeRunSync\n// Blog post ``1''!\nFor further detail see Guice wiki on Multibindings.","title":"Multibindings / Set Bindings"},{"location":"/distage/index.html#provider-bindings","text":"To bind to a function instead of constructor use .from method in ModuleDef DSL:\ncase class HostPort(host: String, port: Int)\n\nclass HttpServer(hostPort: HostPort)\n\ntrait HttpServerModule extends ModuleDef {\n  make[HttpServer].from {\n    hostPort: HostPort => new HttpServer(hostPort.host, hostPort + 1000)\n  }\n}\nTo inject named instances or config values, add annotations to lambda arguments’ types:\ntrait HostPortModule extends ModuleDef {\n  make[HostPort].from {\n    (configHost: String @ConfPath(\"http.host\"), configPort: Int @ConfPath(\"http.port\")) =>\n      HostPort(configHost, configPort)\n  }\n}\nFor further details, see scaladoc for ProviderMagnet","title":"Provider Bindings"},{"location":"/distage/index.html#tagless-final-style-with-distage","text":"distage has first-class support for tagless final style. Let’s see what freestyle tagless example looks like in distage:\nclass Program[F: TagK: Monad] extends ModuleDef {\n  make[TaglessProgram[F]]\n}\n\nobject TryInterpreters extends ModuleDef {\n  make[Validation.Handler[Try]].from(tryValidationHandler)\n  make[Interaction.Handler[Try]].from(tryInteractionHandler)\n}\n\n// Combine modules into a full program\nval TryProgram = new Program[Try] ++ TryInterpreters\nwhere\nclass TaglessProgram[F[_]: Monad](validation: Validation[F], interaction: Interaction[F]) {\n  def program = for {\n      userInput <- interaction.ask(\"Give me something with at least 3 chars and a number on it\")\n      valid     <- (validation.minSize(userInput, 3), validation.hasNumber(userInput)).mapN(_ && _)\n      _         <- if (valid) interaction.tell(\"awesomesauce!\") else interaction.tell(s\"$userInput is not valid\")\n  } yield ()\n}\n\nval validationHandler = new Validation.Handler[Try] {\n  override def minSize(s: String, n: Int): Try[Boolean] = Try(s.size >= n)\n  override def hasNumber(s: String): Try[Boolean] = Try(s.exists(c => \"0123456789\".contains(c)))\n}\n\nval interactionHandler = new Interaction.Handler[Try] {\n  override def tell(s: String): Try[Unit] = Try(println(s))\n  override def ask(s: String): Try[String] = Try(\"This could have been user input 1\")\n}\nNotice how the program module stays completely polymorphic and abstracted from its eventual interpeter or the monad it will run in? Want a program in different Monad? No problem:\nval IOProgram = new Program[IO] ++ IOInterpreters\nWant a program in the same Monad, but with different interpreters? No problem either:\nval DifferentTryProgram = new Program[Try] ++ DifferentTryInterpreters\ndistage makes tagless final style easier and safer by making your implicit instances explicit and configurable as first-class values. It even enforces typeclass coherence by disallowing multiple instances, so one wrong import can’t ruin your day. distage doesn’t make you choose between OO and FP, it lets you use both without losing neither ease of configuration and variability of a runtime DI framework, nor parametricity and equational reasoning of pure FP style.","title":"Tagless Final Style with distage"},{"location":"/distage/index.html#config-files","text":"We provide first-class integration with typesafe-config, rendering a lot of parsing boilerplate unnecessary.\nTo use it, add distage-config library:\nlibraryDependencies += Izumi.R.distage_config\nor\nlibraryDependencies += \"com.github.pshirshov.izumi.r2\" %% \"distage-config\" % \"0.6.0-SNAPSHOT\"\nIf you’re not using sbt-izumi-deps plugin.\nWrite a config in HOCON format:\n# resources/application.conf\nprogram {\n    config {\n        different = true\n    }\n}\nAdd ConfigModule to your injector:\nimport distage.config._\nimport com.typesafe.config.ConfigFactory\n\nval config = ConfigFactory.load()\n\nval injector = Injector(new ConfigModule(AppConfig(config)))\nNow you can automatically parse config entries into case classes and can summon them from any class:\nfinal case class Config(different: Boolean)\n\nclass ConfiguredTaglessProgram[F](\n  @ConfPath(\"program.config\") config: Config,\n  @Id(\"primary\") primaryProgram: TaglessProgram[F],\n  @Id(\"different\") differentProgram: TaglessProgram[F]) {\n\n    val program = if (config.different) differentProgram else primaryProgram\n}\n\nclass ConfiguredTryProgram[F: TagK: Monad] extends ModuleDef {\n  make[ConfiguredProgram[F]]\n  make[TaglessProgram[F]].named(\"primary\")\n  make[TaglessProgram[F]].named(\"different\")\n}","title":"Config files"},{"location":"/distage/index.html#auto-factories-auto-traits","text":"…","title":"Auto-Factories & Auto-Traits"},{"location":"/distage/index.html#patterns","text":"","title":"Patterns"},{"location":"/distage/index.html#import-materialization","text":"…","title":"Import Materialization"},{"location":"/distage/index.html#depending-on-future-values-with-by-name-parameters","text":"…","title":"Depending on future values with by-name parameters"},{"location":"/distage/index.html#ensuring-service-boundaries-using-api-modules","text":"…","title":"Ensuring service boundaries using API modules"},{"location":"/distage/index.html#plugins","text":"When rapidly prototyping, the friction of adding new modules can become a burden. distage plugin extension can alleviate that by automatically picking up all the Plugin modules defined in the program.\nNote that auto plugins are incompatible with distage static checks. Our preferred workflow is to start with plugins, then switch to static configurations after a service has been stabilized.\nTo define a plugin, first add distage-plugins library:\nlibraryDependencies += Izumi.R.distage_plugins\nor\nlibraryDependencies += \"com.github.pshirshov.izumi.r2\" %% \"distage-plugins\" % \"0.6.0-SNAPSHOT\"\nIf you’re not using sbt-izumi-deps plugin.\nCreate a module extending the PluginDef trait instead of ModuleDef:\npackage com.example.petstore\n\nimport distage._\nimport distage.plugins._\n\ntrait PetStorePlugin extends PluginDef {\n  make[PetRepository]\n  make[PetStoreService]\n  make[PetStoreController]\n}\nAt your app entry point use a plugin loader to discover all PluginDefs:\nval pluginLoader = new PluginLoaderDefaultImpl(\n  PluginConfig(\n    debug = true\n    , packagesEnabled = Seq(\"com.example\") // packages to scan\n    , packagesDisabled = Seq.empty         // packages to ignore\n  )\n)\n\nval appModules: Seq[PluginBase] = pluginLoader.load()\nval app: ModuleBase = appModules.merge\nLaunch as normal with the loaded modules:\nInjector().produce(app).get[PetStoreController].run\nPlugins also allow a program to dynamically extend itself by adding new Plugin classes on the classpath at launch time with java -cp","title":"Plugins"},{"location":"/distage/index.html#roles","text":"…","title":"Roles"},{"location":"/distage/index.html#test-kit","text":"","title":"Test Kit"},{"location":"/distage/index.html#fixtures-and-utilities","text":"…","title":"Fixtures and utilities"},{"location":"/distage/index.html#static-configurations","text":"…","title":"Static Configurations"},{"location":"/distage/index.html#using-garbage-collector-to-instantiate-only-classes-required-for-the-test","text":"…","title":"Using Garbage Collector to instantiate only classes required for the test"},{"location":"/distage/index.html#detailed-feature-overview","text":"","title":"Detailed Feature Overview"},{"location":"/distage/index.html#implicits-injection","text":"…","title":"Implicits Injection"},{"location":"/distage/index.html#typeclass-coherence-guarantees","text":"","title":"Typeclass Coherence Guarantees"},{"location":"/distage/index.html#compile-time-checks","text":"…","title":"Compile-Time Checks"},{"location":"/distage/index.html#circular-dependencies-support","text":"…","title":"Circular Dependencies support"},{"location":"/distage/index.html#automatic-resolution-with-generated-proxies","text":"","title":"Automatic Resolution with generated Proxies"},{"location":"/distage/index.html#manual-resolution-with-by-name-parameters","text":"","title":"Manual Resolution with by-name parameters"},{"location":"/distage/index.html#auto-sets-collecting-bindings-by-predicate","text":"…","title":"Auto-Sets: Collecting Bindings By Predicate"},{"location":"/distage/index.html#weak-sets","text":"","title":"Weak Sets"},{"location":"/distage/index.html#debugging-introspection-diagnostics-and-hooks","text":"You can print a plan to get detailed info on what will happen during instantiation. The printout includes file:line info so your IDE can show you where the binding was defined!\nSystem.err.println(plan: OrderedPlan)\nYou can also query a plan to see the dependencies and reverse dependencies of a class and their instantiation:\n// Print dependencies\nSystem.err.println(plan.topology.dependencies.tree(DIKey.get[Circular1]))\n// Print reverse dependencies\nSystem.err.println(plan.topology.dependees.tree(DIKey.get[Circular1]))\nThe printer highlights circular dependencies.\nDistage also uses some macros, macros are currently used to create TagKs and provider bindings. If you think they’ve gone awry, you can turn macro debug output during compilation by setting -Dizumi.distage.debug.macro=true java property:\nsbt -Dizumi.distage.debug.macro=true compile\nMacros power distage-static module, an alternative backend that doesn’t use JVM runtime reflection.","title":"Debugging, Introspection, Diagnostics and Hooks"},{"location":"/distage/index.html#extensions-and-plan-rewriting-writing-a-distage-extension","text":"…","title":"Extensions and Plan Rewriting – writing a distage extension"},{"location":"/distage/index.html#migrating-from-guice","text":"…","title":"Migrating from Guice"},{"location":"/distage/index.html#migrating-from-macwire","text":"…","title":"Migrating from MacWire"},{"location":"/distage/index.html#integrations","text":"…","title":"Integrations"},{"location":"/distage/index.html#cats","text":"To import cats integration add distage-cats library:\nlibraryDependencies += Izumi.R.distage_cats\nor\nlibraryDependencies += \"com.github.pshirshov.izumi.r2\" %% \"distage-cats\" % \"0.6.0-SNAPSHOT\"\nIf you’re not using sbt-izumi-deps plugin.\nUsage:\nimport cats.implicits._\nimport cats.effect._\nimport distage._\nimport distage.interop.cats._\nimport com.example.{DBConnection, AppEntrypoint}\n\nobject Main extends IOApp {\n  def run(args: List[String]): IO[Unit] = {\n    val myModules = module1 |+| module2 // Monoid instance for ModuleDef is available now\n    \n    for {\n      plan <- myModules.resolveImportsF[IO] { // resolveImportsF is now available\n        case i if i.target == DIKey.get[DBConnection] =>\n           DBConnection.create[IO]\n      } \n      classes <- Injector().produceIO[IO](plan) // produceIO is now available\n      _ <- classes.get[AppEntrypoint].run\n    } yield ()\n  }\n}","title":"Cats"},{"location":"/distage/index.html#scalaz","text":"","title":"Scalaz"},{"location":"/distage/index.html#freestyle","text":"","title":"Freestyle"},{"location":"/distage/index.html#eff","text":"","title":"Eff"},{"location":"/distage/index.html#pper","text":"See PPER Overview","title":"PPER"},{"location":"/logstage/index.html","text":"","title":"LogStage"},{"location":"/logstage/index.html#logstage","text":"LogStage is a zero-cost structural logging framework.\nKey features:\nLogStage extracts structure out of your log messages. In compile time. For free. So, you may write usual logging expressions but they may be automatically converted into meaningful JSON, LogStage uses macro code generation to extract logging context so it does not depend on reflection and is cheaper than a typical framework in runtime, Log contexts Console and File sinks included, File sink supports log rotation, Human-readable and JSON formatting included, Method-level logging granularity. You may configure com.mycompany.Service.start and com.mycompany.Service.doSomething independently, Slf4J adapters: you may stream all the logging made with Slf4J into LogStage router (as well you may route LogStage messages into slf4j but in a typical case you won’t need it).","title":"LogStage"},{"location":"/logstage/index.html#overview","text":"The following snippet:\nclass ExampleService(logger: IzLogger) {\n    val justAnArg = \"example\"\n    val justAList = List[Any](10, \"green\", \"bottles\")\n\n    logger.trace(s\"Argument: $justAnArg, another arg: $justAList\")\n    logger.info(s\"Named expression: ${Random.nextInt() -> \"random number\"}\")\n    logger.warn(s\"Invisible argument: ${Random.nextInt() -> \"random number\" -> null}\")\n\n    val ctxLogger = logger(\"userId\" -> \"user@google.com\", \"company\" -> \"acme\")\n    val delta = Random.nextInt(1000)\n\n    ctxLogger.info(s\"Processing time: $delta\")\n}\nWill look like this in string form:\nAnd like this in JSON:\nNote:\nJSON formatter is type aware! Each JSON message contains @class field which holds an unique identifier for event class. So, all the events produced by the same logger line would have the same class despite of argument values.","title":"Overview"},{"location":"/logstage/index.html#dependencies","text":"val izumi_version = \"0.6.0-SNAPSHOT\"\n// LogStage API, you need it to use the logger\nlibraryDependencies += \"com.github.pshirshov.izumi.r2\" %% \"logstage-api-logger\" % izumi_version\n\n// LogStage machinery\nlibraryDependencies ++= Seq(\n    // console sink\n    \"com.github.pshirshov.izumi.r2\" %% \"logstage-sink-console\" % izumi_version\n    // file sink\n    , \"com.github.pshirshov.izumi.r2\" %% \"logstage-sink-file\" % izumi_version\n    // json formatting\n    , \"com.github.pshirshov.izumi.r2\" %% \"logstage-json-json4s\" % izumi_version\n    // adapter for Slf4J loggers\n    , \"com.github.pshirshov.izumi.r2\" %% \"logstage-adapter-slf4j\" % izumi_version    \n)\n\n//","title":"Dependencies"},{"location":"/logstage/index.html#basic-setup","text":"import com.github.pshirshov.izumi.logstage.api._\n    import com.github.pshirshov.izumi.logstage.api.Log._\n    import com.github.pshirshov.izumi.logstage.api.config._\n    import com.github.pshirshov.izumi.logstage.api.logger._\n    import com.github.pshirshov.izumi.logstage.api.routing._\n    import com.github.pshirshov.izumi.logstage.api.rendering._\n\n    val jsonSink = new ConsoleSink(new JsonRenderingPolicy())\n    val textSink = new ConsoleSink(new StringRenderingPolicy(RenderingOptions(withExceptions = true, withColors = true)))\n\n    val sinks = List(jsonSink, textSink)\n\n    val configService = new LogConfigServiceStaticImpl(Map.empty, LoggerConfig(Log.Level.Trace, sinks))\n    val router = new ConfigurableLogRouter(configService)\n\n    val logger = new IzLogger(router, CustomContext.empty)\n    val contextLogger = logger(Map(\"key\" -> \"value\"))","title":"Basic setup"},{"location":"/logstage/policy.html","text":"","title":"Rendering policy"},{"location":"/logstage/policy.html#rendering-policy","text":"Rendering policy defines how incoming log event will be transformed into a string. Rendering layout defines in a logstage config section. Rendering policy has string interpolator-like format. Each component (named as Log Unit) defines like ${log_unit_label} in string.\nDefault template: ${level}:${ts} ${thread}${location} ${custom-ctx} ${msg}","title":"Rendering policy"},{"location":"/logstage/policy.html#log-units-specification","text":"Unit Aliases Explanation Syntax timestamp ts Timestamp ${timestamp} thread t Thread data (contains thread name and id) ${thread} level lvl Logging level ${lvl} location loc Log message location (hyperlink to filename it’s line number) ${location} message msg Application-supplied message associated with the logging event ${message} custom-ctx context, ctx User’s context (more info here) ${custom-ctx} exception ex Outputs the stack trace of the exception associated with the logging event, if any. By default the full stack trace will be output. ${ex}","title":"Log units specification"},{"location":"/logstage/policy.html#parameters","text":"Each log unit has parameters. (example, padding, margins, etc). There are common parameters for all log units and specific for each one. NOTE! Currently there are only common parameters (padding). Parameters enumerates in [ ] braces. For example, ${message[15]}\nLog unit Features Explanation Example common padding padding for log unit in result string. It maybe default padding or ellipsed ([:..14]) ${timestamp}[14]","title":"Parameters"},{"location":"/logstage/policy.html#todo-","text":"define params for each log unit provide intuitive syntax for their definition tests!","title":"TODO:"},{"location":"/logstage/config.html","text":"","title":"· Izumi Toolkit"},{"location":"/logstage/custom_ctx.html","text":"","title":"· Izumi Toolkit"},{"location":"/sbt/index.html","text":"","title":"SBT Toolkit"},{"location":"/sbt/index.html#sbt-toolkit","text":"Izumi provides you a bunch of sbt plugins allowing you to significantly reduce size and increase clarity of huge multi-module builds.\nTo start using Izumi plugins add the following into your project/plugins.sbt:\nval izumi_version = \"0.6.0-SNAPSHOT\"\naddSbtPlugin(\"com.github.pshirshov.izumi.r2\" % \"sbt-izumi\" % izumi_version)\n// This is a Izumi's Bill of Materials, see below\naddSbtPlugin(\"com.github.pshirshov.izumi.r2\" % \"sbt-izumi-deps\" % izumi_version)\nWe provide you the following kinds of plugins:\nGlobal plugins: they add some helper sbt tasks, enabled automatically, Environmental plugins: they change some aspects of sbt behavior in an opinionated way, intended to be enabled in the root project, Presets - opinionated sets of environmental plugins, Optional plugins: they provide some convenience sbt tasks, intended to be enabled manually, per-project.\nImportant notes:\nPlease keep in mind no plugins are being enabled automatically, The rest of Izumi plugins are optional. You may use a preset to activate them or combine them manually as you wish (using settings groups), Some plugins can’t be enabled globally due to sbt limitations – they have to be enabled per-project. You should use Settings Groups in order to enable them.","title":"SBT Toolkit"},{"location":"/sbt/index.html#global-plugins","text":"Plugin Description IzumiImportsPlugin Makes all the Izumi imports visible by default","title":"Global plugins"},{"location":"/sbt/index.html#environmental-plugins","text":"Plugin Description IzumiBuildManifestPlugin Adds build info into jar manifests IzumiConvenienceTasksPlugin Devops/workflow helpers IzumiDslPlugin Compact build definitions IzumiGitStampPlugin Adds GIT status into jar manifests IzumiPropertiesPlugin Convenience helpers for sys.props IzumiResolverPlugin Better defaults for artifact resolution IzumiInheritedTestScopesPlugin Convenience helpers for test scope inheritance","title":"Environmental plugins"},{"location":"/sbt/index.html#presets","text":"Plugin Description IzumiEnvironment All the environmental plugins except of GIT one IzumiGitEnvironment All the environmental plugins with GIT one","title":"Presets"},{"location":"/sbt/index.html#optional-plugins","text":"Plugin Description IzumiExposedTestScopesPlugin Maintains test scope separation IzumiCompilerOptionsPlugin Some linting/optimization presets for scalac/javac IzumiFetchPlugin Allows you to transitively download artifacts from remote repositories IzumiPublishingPlugin Some convenience helpers and improvements for artifact publishing IzumiBuildInfoPlugin Generates sbt-compatible BOMs – Bills of Materials","title":"Optional plugins"},{"location":"/sbt/index.html#installation","text":"To activate all the plugins add the following statements into your root project:\nenablePlugins(IzumiGitEnvironmentPlugin)\nIf you don’t use git in your project, use this preset instead:\nenablePlugins(IzumiEnvironmentPlugin)\nTo activate Comp\nval GlobalSettings = new DefaultGlobalSettingsGroup {\n  override val plugins = Set(IzumiCompilerOptionsPlugin, IzumiExposedTestScopesPlugin)\n}","title":"Installation"},{"location":"/sbt/index.html#inherited-test-scopes","text":"","title":"Inherited Test Scopes"},{"location":"/sbt/index.html#test-scope-inheritance","text":"IzumiScopesPlugin extends SBT Project with several implicit methods:\ntestOnlyRef - provides you a project reference which is equivalent to % \"test\" dependency, dependsSeq and depends - allow you to add dependencies to your project the way test scopes of your dependencies are visible within test scopes of your project. So, essentially when you use these methods your dependencies are added into your projects with the following qualifier: \"test->compile,test;it->compile,test,it\"\nYou need to activate DefaultItSettingsGroup on your projects (see “Setting Groups” below) in order to make this working on it scope.\nExample:\nlazy val myLibrary = ...\n\nlazy val myProject = (...).depends(myLibrary)\nSo, now you may use classes from the test scope of myLibrary within test scope of myProject","title":"Test Scope Inheritance"},{"location":"/sbt/index.html#test-scope-separation","text":"InheritedTestScopesPlugin works in pair with IzumiScopesPlugin and provides you an unique feature: only the classes you marked with @ExposedTestScope are being exposed to dependant artifacts.\nSo, let’s assume that:\nyou have two artifacts, Library and App, App depends on Library, In the test scope of Library you have a class named TestSuite, In the test scope of Library you have another class named TestUtil, TestUtil is annotated with @ExposedTestScope,\nin that case TestUtil will be visible in App’s test scope, but TestSuite will not be visible.\nA diagram:\n+-----------------------------------------+     +-----------------------------------------+\n| Library                                 |     | App                                     |\n|-----------------------------------------|     |-----------------------------------------|\n| Main scope                              |     | Main scope                              |\n|                                     <---+-----+--                                       |\n| UtilityClass                            |     | AppMain                                 |\n|-----------------------------------------|     |-----------------------------------------+\n| Private Test Scope | Exposed test scope |     | Test scope                              |\n|                    |                <---+-----+--                                       |\n| TestSuite          | TestUtil           |     | Private Test Scope | Exposed test scope |\n+-----------------------------------------+     +-----------------------------------------+\nNotes:\nIntellij IDEA doesn’t support overriden classpaths so when you run your tests under IDEA the whole test scopes are visible in dependencies, At the moment the implementation of @ExposedTestScope (substring presence check) is imperfect and has to be improved, Transitive dependencies are not checked, so in case you expose a class but do not expose it’s dependencies your build will work under IDEA, but you will a classloading exception under sbt. This is going to be improved in the future.","title":"Test Scope Separation"},{"location":"/sbt/index.html#test-scope-publishing","text":"The whole content of test scopes is being published by default with test qualifier. Test scope separation has no effect on test scope publishing.","title":"Test Scope Publishing"},{"location":"/sbt/index.html#settings-dsl","text":"IzumiDslPlugin comes with a DSL intended to simplify definition of complex project layouts.\nTo activate the plugin add the following statement into your root project:\nenablePlugins(IzumiDslPlugin)","title":"Settings DSL"},{"location":"/sbt/index.html#simplified-identifiers","text":"DSL provides syntax to simplify project definitions. A definition such as this:\nlazy val petstoreApp = In(\"app\").as.module\nexpands to\nlazy val petstoreApp = project.in(\"app/petstore-app\")\nYou can attach settings and dependencies to the In part, that way you can apply common settings to all the projects in a directory:\nval ApiSettings: SettingsGroup = new SettingsGroup {\n  override val plugins = Set(IdealinguaPlugin)\n}\n\nlazy val inApi = In(\"api\")\n\nlazy val petstoreApi = inApi.as.module\nlazy val todomvcApi = inApi.as.module","title":"Simplified Identifiers"},{"location":"/sbt/index.html#setting-groups","text":"","title":"Setting Groups"},{"location":"/sbt/index.html#global-setting-group","text":"","title":"Global Setting Group"},{"location":"/sbt/index.html#automatic-aggregation","text":"When you use .as.project or .as.module syntax to define a project, that project is stored in a global singleton.\nYou may use transitiveAggregate or transitiveAggregateSeq methods instead of standard aggregate, in that case all the transitive dependencies of the projects provided will be also added into aggregation list. This allows you to simplify your definitions by avoiding specifing all the modules in .aggregate.\nIn case you don’t want your project to be recorded, you shoud use .as.just syntax.\nImportant note: sbt is lazy! We just store project reference in a singleton list, we don’t analyze dependency graph. Though sbt relies on lazy val declarations. So, in fact the singleton initializes at the moment you invoke aggregation. In case you don’t add a project into aggregation list such a project still will be initialized by sbt and added into the singleton, but it would happen later than evaluation of aggregation list so the project will not be aggregated.","title":"Automatic Aggregation"},{"location":"/sbt/index.html#aggregation-safety-check","text":"When you invoke transitiveAggregate or transitiveAggregateSeq on your root project it checks if the accumulated set of known project is the same as the set of all projects loaded by sbt.\nIn case module is missing you’ll get a warning. This makes it unlikely for you to accidentally forget to aggregate a module in multi-module project.","title":"Aggregation Safety Check"},{"location":"/sbt/index.html#build-descriptors","text":"","title":"Build Descriptors"},{"location":"/sbt/index.html#bills-of-materials","text":"Izumi brings Bill of Materials concept to SBT.","title":"Bills of Materials"},{"location":"/sbt/index.html#izumi-bom","text":"You can import Izumi libraries and transitive dependencies without specifying their version or even artifact names. To do that add sbt-izumi-deps SBT plugin:\nval izumi_version = \"0.6.0-SNAPSHOT\"\naddSbtPlugin(\"com.github.pshirshov.izumi.r2\" % \"sbt-izumi-deps\" % izumi_version)\nYou can use it like this:\nlibraryDependencies += Izumi.R.distage_core // Import an izumi library\nlibraryDependencies += Izumi.D.cats_effect // Import an izumi dependency\nR is for Runtime, D is for Dependencies, T is for Test artifacts","title":"Izumi BOM"},{"location":"/sbt/index.html#create-a-bom-for-your-projects","text":"sbt-izumi-deps also allows you to a BOM for your own projects. Just add just one line into your project settings:\nlazy val myProject = (project in file(\"my-project-bom\"))\n  .settings(withBuildInfo(\"com.mycompany.myproject\", \"MyProjectBOM\"))\nIn case you use Izumi DSL it would be something like:\nlazy val inRoot = In(\".\")\nlazy val myProjectBom = inRoot.as.module\n  .settings(withBuildInfo(\"com.mycompany.myproject\", \"MyProjectBOM\"))","title":"Create a BOM for your projects"},{"location":"/sbt/index.html#build-manifest-entries","text":"","title":"Build Manifest entries"},{"location":"/sbt/index.html#git-manifest-entries","text":"GitStampPlugin adds the following values into MANIFEST.MF of each jar artifact produced:\nManifest Key Description X-Git-Branch The name of branch sbt was invoked on X-Git-Repo-Is-Clean true or false, indicates if GIT repo was in clean state when the build was invoked X-Git-Head-Rev GIT revision on which sbt was invoked\nTo activate the plugin add the following statement into your root project:\nenablePlugins(GitStampPlugin)","title":"Git Manifest entries"},{"location":"/sbt/index.html#convenience-helpers","text":"","title":"Convenience Helpers"},{"location":"/sbt/index.html#stub-generators","text":"ConvenienceTasksPlugin provides you the following commands:\nnewModule <module_path/module_name> [package.suffix]: creates empty project layout at /module_path/module_name. Optional package.suffix may be specified. newStub <module_path/module_name> [stub_name:default]: copies /stubs/${stub_name} into /module_path/module_name. stub_name may be omitted, default value is default\nSetting Description ConvenienceTasksPlugin.Keys.mkJavaDirs Also adds src/*/java directories into generated stubs ConvenienceTasksPlugin.Keys.defaultStubPackage Default stub package. By default same as project’s organization","title":"Stub Generators"},{"location":"/sbt/index.html#version-suffixes","text":"ConvenienceTasksPlugin provides you command\naddVersionSuffix SUFFIX\nThis command updates project version defined in version.sbt with qualifier SUFFIX-SNAPSHOT\nExisting qualifiers will be removed. 1.0.0 would become 1.0.0-SUFFIX-SNAPSHOT 1.0.0-SNAPSHOT would become 1.0.0-SUFFIX-SNAPSHOT\nYou may need this command while setting up a build for feature branches and wish to avoid situation when different branches publishes artifacts with the same names.","title":"Version Suffixes"},{"location":"/sbt/index.html#target-preservation","text":"ConvenienceTasksPlugin provides you command\npreserveTargets SUFFIX\nThis command recursively enumerates all the directories named target and recursively copies them using name target.SUFFIX.\nYou may need this command while setting up a build where you wish to perform clean several times but want to preserve intermediate build artifacts stored in target directories. The most frequent case is coverage build followed by tests and then by production build. In this case you would like to use a command sequence like\n;clean;coverage;test;coverageOff;coverageReport;preserveTargets coverage;clean;publish","title":"target preservation"},{"location":"/sbt/index.html#directory-cleanups","text":"ConvenienceTasksPlugin provides you command\nrmDirs target.coverage\nThis command recursively removes all the directories named target.coverage across the project.\nYou may need this command to cleanup preserved target directories, or destroy some build artifacts, like rmDirs scala-2.11","title":"Directory cleanups"},{"location":"/sbt/index.html#property-readers","text":"IzumiPropertiesPlugin provides you implicit classes allowing you to convert Strings into Integers or Booleans exceptions-safe and do the same for system properties:\n\"true\".asBoolean(default = false) // true\n\"junk\".asBoolean(default = false) // false\n\"123\".asInt(default = 265) // 123\n\"junk\".asInt(default = 265) // 265\nsys.props.asBoolean(\"my.property\", default = false)\nsys.props.asInt(\"my.property\", default = 123)\nYou may activate this plugin with the following statement in root project:","title":"Property Readers"},{"location":"/sbt/index.html#transitive-artifact-downloader","text":"TODO","title":"Transitive Artifact Downloader"},{"location":"/sbt/index.html#optional-settings","text":"","title":"Optional settings"},{"location":"/sbt/index.html#publishing","text":"TODO","title":"Publishing"},{"location":"/sbt/index.html#publishing-settings","text":"TODO","title":"Publishing settings"},{"location":"/sbt/index.html#publishing-credentials-and-targets","text":"TODO","title":"Publishing credentials and targets"},{"location":"/sbt/index.html#compiler-options","text":"CompilerOptionsPlugin provides you some sane compiler option presets (linting, optimizations).\nYou should explicitly enable this plugin in each project you want to use it. When you want to enable it globally, use a settings group:\nval GlobalSettings = new SettingsGroup {\n  override val plugins = Set(\n      IzumiCompilerOptionsPlugin,\n      // ...\n  )\n  // ...\n}","title":"Compiler options"},{"location":"/sbt/index.html#resolvers","text":"ResolverPlugin turns on the following settings which should speedup your dependency resolution:\nupdateOptions := updateOptions\n      .value\n      .withCachedResolution(true)\n      .withGigahorse(true)","title":"Resolvers"},{"location":"/manifesto/index.html","text":"","title":"Productivity and challenges"},{"location":"/manifesto/index.html#productivity-and-challenges","text":"TODO Sorry, this page is not ready yet","title":"Productivity and challenges"},{"location":"/pper/index.html","text":"","title":"PPER Pattern"},{"location":"/pper/index.html#pper-pattern","text":"TODO Sorry, this page is not ready yet","title":"PPER Pattern"}]}